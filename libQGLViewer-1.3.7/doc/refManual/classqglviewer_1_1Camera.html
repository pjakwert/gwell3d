<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Camera class Reference</title>
<link href="qglviewer.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="functions.html">All&nbsp;functions</a> | <a class="qindex" doxygen="_cgi:http://www-imagis.imag.fr/cgi-bin/DOXYGEN/search.cgi" href="http://www-imagis.imag.fr/cgi-bin/DOXYGEN/search.cgi">Search</a> &nbsp; </center>
<hr><h1>Camera Class Reference</h1>An OpenGL camera, with positioning tools. 
<a href="#_details">More...</a>
<p>
<a href="classqglviewer_1_1Camera-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Position and orientation of the camera</h2></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classqglviewer_1_1Vec.html">Vec</a>&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z1_0">position</a> () const</td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classqglviewer_1_1Quaternion.html">Quaternion</a>&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z1_1">orientation</a> () const</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z1_2">getPosition</a> (float &amp;x, float &amp;y, float &amp;z) const</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z1_3">getOrientation</a> (float &amp;q0, float &amp;q1, float &amp;q2, float &amp;q3) const</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z1_4">setPosition</a> (const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;pos)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z1_5">setPosition</a> (float x, float y, float z)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z1_6">setOrientation</a> (const <a class="el" href="classqglviewer_1_1Quaternion.html">Quaternion</a> &amp;q)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z1_7">setOrientation</a> (float q0, float q1, float q2, float q3)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z1_8">setOrientation</a> (float theta, float phi)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z1_9">setCameraFromProjectionMatrix</a> (const float *const m)</td></tr>
<tr><td colspan=2><br><h2>Positioning tools</h2></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z3_0">setUpVector</a> (float x, float y, float z, bool noMove=true)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z3_1">showEntireScene</a> ()</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z3_2">fitBoundingBox</a> (const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;m, const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;M)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z3_3">fitSphere</a> (const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;center, float radius)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z3_4">fitSphere</a> (float x, float y, float z, float r)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z3_5">lookAt</a> (const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;target)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z3_6">lookAt</a> (float x, float y, float z)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z3_7">centerScene</a> ()</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z3_8">setUpVector</a> (const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;up, bool noMove=true)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z3_9">fitScreenRegion</a> (int xa, int ya, int xb, int yb)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z3_10">setFOVToFitScene</a> ()</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z3_11">interpolateToZoomOnPixel</a> (int x, int y)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z3_12">interpolateToFitScene</a> ()</td></tr>
<tr><td colspan=2><br><h2>Intrinsic parameters</h2></td></tr>
<tr><td nowrap align=right valign=top>float&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z5_0">fieldOfView</a> () const</td></tr>
<tr><td nowrap align=right valign=top>float&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z5_1">horizontalFieldOfView</a> () const</td></tr>
<tr><td nowrap align=right valign=top>float&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z5_2">flySpeed</a> () const</td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classqglviewer_1_1Camera.html#s2">Type</a>&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z5_3">type</a> () const</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z5_4">setFieldOfView</a> (float f)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z5_5">setHorizontalFieldOfView</a> (float hfov)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z5_6">setFlySpeed</a> (float s)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z5_7">setType</a> (<a class="el" href="classqglviewer_1_1Camera.html#s2">Type</a> type)</td></tr>
<tr><td colspan=2><br><h2>Associated parameters</h2></td></tr>
<tr><td nowrap align=right valign=top>virtual float&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z7_0">zNear</a> () const</td></tr>
<tr><td nowrap align=right valign=top>virtual float&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z7_1">zFar</a> () const</td></tr>
<tr><td nowrap align=right valign=top>float&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z7_2">zNearCoef</a> () const</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z7_3">getOrthoWidthHeight</a> (GLdouble &amp;w, GLdouble &amp;h) const</td></tr>
<tr><td nowrap align=right valign=top>float&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z7_4">aspectRatio</a> () const</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z7_5">screenWidth</a> () const</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z7_6">screenHeight</a> () const</td></tr>
<tr><td nowrap align=right valign=top>float&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z7_7">pixelGLRatio</a> (const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;pos)</td></tr>
<tr><td nowrap align=right valign=top>float&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z7_8">distanceToSceneCenter</a> () const</td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classqglviewer_1_1Vec.html">Vec</a>&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z7_9">upVector</a> () const</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z7_10">getUpVector</a> (float &amp;x, float &amp;y, float &amp;z) const</td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classqglviewer_1_1Vec.html">Vec</a>&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z7_11">viewDirection</a> () const</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z7_12">getViewDirection</a> (float &amp;x, float &amp;y, float &amp;z) const</td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classqglviewer_1_1Vec.html">Vec</a>&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z7_13">pointUnderPixel</a> (const int x, const int y, bool &amp;found)</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z7_14">isManipulated</a> () const</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z7_15">getViewport</a> (GLint viewport[4]) const</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z7_16">setZNearCoef</a> (float coef)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z7_17">setAspectRatio</a> (float ar)</td></tr>
<tr><td colspan=2><br><h2>Revolve Around Point</h2></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classqglviewer_1_1Vec.html">Vec</a>&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z9_0">revolveAroundPoint</a> () const</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z9_1">getRevolveAroundPoint</a> (float &amp;x, float &amp;y, float &amp;z) const</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z9_2">setRevolveAroundPoint</a> (const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;rap)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z9_3">setRevolveAroundPoint</a> (float x, float y, float z)</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z9_4">setRevolveAroundPointFromPixel</a> (int x, int y)</td></tr>
<tr><td colspan=2><br><h2>Paths</h2></td></tr>
<tr><td colspan=2>A camera path is defined by a KeyFrameInterpolator. You can interactively addKeyFrame() to a given path using the default <a class="el" href="classQGLViewer.html">QGLViewer</a> shortcut: Alt-F[1-12] (see <a class="el" href="classQGLViewer.html#z109_4">QGLViewer::setKeyFrameKey()</a>). Use playKeyFramePath() to make the camera follow the path (default shortcut is F[1-12]).<br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z11_0">nbPaths</a> () const</td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html">KeyFrameInterpolator</a> *&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z11_1">keyFrameInterpolator</a> (unsigned short i) const</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z11_2">setKeyFrameInterpolator</a> (unsigned short i, <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html">KeyFrameInterpolator</a> *const kfi)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z11_3">addKeyFrame</a> (unsigned short i)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z11_4">playKeyFramePath</a> (unsigned short i)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z11_5">deleteKeyFramePath</a> (unsigned short i)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z11_6">resetKeyFramePath</a> (unsigned short i)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z11_7">drawAllPaths</a> ()</td></tr>
<tr><td colspan=2><br><h2>Associated frame</h2></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classqglviewer_1_1ManipulatedCameraFrame.html">ManipulatedCameraFrame</a> *&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z13_0">frame</a> () const</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z13_1">setFrame</a> (<a class="el" href="classqglviewer_1_1ManipulatedCameraFrame.html">ManipulatedCameraFrame</a> *const f)</td></tr>
<tr><td colspan=2><br><h2>OpenGL associated matrices</h2></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z15_0">loadProjectionMatrix</a> (bool reset=true) const</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z15_1">loadProjectionMatrixStereo</a> (bool leftBuffer=true) const</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z15_2">loadModelViewMatrix</a> (bool reset=true) const</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z15_3">loadModelViewMatrixStereo</a> (bool leftBuffer=true) const</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z15_4">getProjectionMatrix</a> (GLdouble m[16]) const</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z15_5">getProjectionMatrix</a> (GLfloat m[16]) const</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z15_6">getModelViewMatrix</a> (GLdouble m[16]) const</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z15_7">getModelViewMatrix</a> (GLfloat m[16]) const</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z15_8">computeModelViewMatrix</a> () const</td></tr>
<tr><td colspan=2><br><h2>World to Camera coordinate systems</h2></td></tr>
<tr><td colspan=2>Methods to go from the world to the camera coordinate systems, and vice-versa. Simply an interface for the Frame equivalent functions.<br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z17_0">getCameraCoordinatesOf</a> (const float src[3], float res[3]) const</td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classqglviewer_1_1Vec.html">Vec</a>&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z17_1">cameraCoordinatesOf</a> (const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;src) const</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z17_2">getWorldCoordinatesOf</a> (const float src[3], float res[3]) const</td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classqglviewer_1_1Vec.html">Vec</a>&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z17_3">worldCoordinatesOf</a> (const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;src) const</td></tr>
<tr><td colspan=2><br><h2>2D screen to 3D world coordinate systems</h2></td></tr>
<tr><td colspan=2>Methods to go from the 2D screen to the 3D world coordinate systems, and vice-versa.<br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classqglviewer_1_1Vec.html">Vec</a>&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z19_0">projectedCoordinatesOf</a> (const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;src) const</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z19_1">getProjectedCoordinatesOf</a> (const float src[3], float res[3]) const</td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classqglviewer_1_1Vec.html">Vec</a>&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z19_2">unprojectedCoordinatesOf</a> (const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;src) const</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z19_3">getUnprojectedCoordinatesOf</a> (const float src[3], float res[3]) const</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z19_4">convertClickToLine</a> (int x, int y, float orig[3], float dir[3]) const</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z19_5">convertClickToLine</a> (int x, int y, <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;orig, <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;dir) const</td></tr>
<tr><td colspan=2><br><h2>Stereo mode parameters</h2></td></tr>
<tr><td nowrap align=right valign=top>float&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z21_0">IODist</a> () const</td></tr>
<tr><td nowrap align=right valign=top>float&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z21_1">distanceToScreen</a> () const</td></tr>
<tr><td nowrap align=right valign=top>float&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z21_2">distanceToZeroParallaxPlane</a> () const</td></tr>
<tr><td nowrap align=right valign=top>float&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z21_3">physicalScreenWidth</a> () const</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z21_4">setIODist</a> (float iod)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z21_5">setDistanceToScreen</a> (float dts)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z21_6">setDistanceToZeroParallaxPlane</a> (float dtz)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z21_7">setPhysicalScreenWidth</a> (float sw)</td></tr>
<tr><td colspan=2><br><h2>XML representation</h2></td></tr>
<tr><td nowrap align=right valign=top>virtual QDomElement&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z23_0">domElement</a> (const QString &amp;name, QDomDocument &amp;doc) const</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z23_1">initFromDOMElement</a> (const QDomElement &amp;de)</td></tr>
<tr><td colspan=2><br><h2>Scene radius and center</h2></td></tr>
<tr><td nowrap align=right valign=top>float&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z25_0">sceneRadius</a> () const</td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classqglviewer_1_1Vec.html">Vec</a>&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z25_1">sceneCenter</a> () const</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z25_2">setSceneRadius</a> (float r)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z25_3">setSceneBoundingBox</a> (const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;m, const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;M)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z25_4">setSceneCenter</a> (const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;sc)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z25_5">setSceneCenter</a> (float x, float y, float z)</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z25_6">setSceneCenterFromPixel</a> (int x, int y)</td></tr>
<tr><td colspan=2><br><h2>Internal methods</h2></td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z27_0">cameraPathIsEdited</a> () const</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z27_1">editCameraPath</a> (bool edit)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#z27_2">setWindowWidthAndHeight</a> (int w, int h)</td></tr>
<tr><td colspan=2><br><h2>Public Types</h2></td></tr>
<tr><td nowrap align=right valign=top>enum &nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#s2">Type</a> { <a class="el" href="classqglviewer_1_1Camera.html#s2s0">PERSPECTIVE</a>, 
<a class="el" href="classqglviewer_1_1Camera.html#s2s1">ORTHO</a>
 }</td></tr>
<tr><td colspan=2><br><h2>Public Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#a0">Camera</a> ()</td></tr>
<tr><td nowrap align=right valign=top>virtual&nbsp;</td><td valign=bottom><a class="el" href="classqglviewer_1_1Camera.html#a1">~Camera</a> ()</td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
An OpenGL camera, with positioning tools.
<p>
A <a class="el" href="classqglviewer_1_1Camera.html">Camera</a> defines some intrinsic camera parameters, such as <a class="el" href="classqglviewer_1_1Camera.html#z5_0">fieldOfView()</a>, <a class="el" href="classqglviewer_1_1Camera.html#z1_0">position()</a>, <a class="el" href="classqglviewer_1_1Camera.html#z7_11">viewDirection()</a>, <a class="el" href="classqglviewer_1_1Camera.html#z7_9">upVector()</a>... It also provides useful positioning tools that ease its placement : <a class="el" href="classqglviewer_1_1Camera.html#z3_1">showEntireScene()</a>, <a class="el" href="classqglviewer_1_1Camera.html#z3_3">fitSphere()</a>, <a class="el" href="classqglviewer_1_1Camera.html#z3_2">fitBoundingBox()</a>,, ...
<p>
The <a class="el" href="classqglviewer_1_1Camera.html#z5_3">type()</a> of the <a class="el" href="classqglviewer_1_1Camera.html">Camera</a> can be ORTHO or PERSPECTIVE (see <a class="el" href="classqglviewer_1_1Camera.html#s2">Type()</a>). <a class="el" href="classqglviewer_1_1Camera.html#z5_0">fieldOfView()</a> is meaningless in ORTHO.
<p>
The <a class="el" href="classqglviewer_1_1Camera.html#z1_0">position()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z1_1">orientation()</a> of the <a class="el" href="classqglviewer_1_1Camera.html">Camera</a> are defined by a <a class="el" href="classqglviewer_1_1ManipulatedCameraFrame.html">ManipulatedCameraFrame</a> that can be retrieved with <a class="el" href="classqglviewer_1_1Camera.html#z13_0">frame()</a>. These functions are just a convenient interface for the associated <a class="el" href="classqglviewer_1_1Frame.html">Frame</a> functions. This also means that the <a class="el" href="classqglviewer_1_1Camera.html">Camera</a> <a class="el" href="classqglviewer_1_1Camera.html#z13_0">frame()</a> can be attached to a <a class="el" href="classqglviewer_1_1Frame.html#z35_0">Frame::referenceFrame()</a> which enable complex <a class="el" href="classqglviewer_1_1Camera.html">Camera</a> setups.
<p>
Different camera displacements can be performed using the mouse. The list of possible actions is defined by the <a class="el" href="classQGLViewer.html#z111_0">QGLViewer::MouseAction</a> enum. Use <a class="el" href="classQGLViewer.html#z111_2">QGLViewer::setMouseBinding()</a> to attach a specific action to an arbitrary mouse button-state key binding. These actions are detailed in the  <a href="../mouse.html">mouse page</a>.
<p>
The default button binding are : <a class="el" href="classQGLViewer.html#z111_0s1">QGLViewer::ROTATE</a> (left), <a class="el" href="classQGLViewer.html#z111_0s2">QGLViewer::ZOOM</a> (middle) and <a class="el" href="classQGLViewer.html#z111_0s3">QGLViewer::TRANSLATE</a> (right). With this configuration, the camera <em>observes</em> a scene and rotates around its <a class="el" href="classqglviewer_1_1Camera.html#z9_0">revolveAroundPoint()</a>. You can switch between this mode and a walkthrough mode using the <a class="el" href="classQGLViewer.html#z109_10t7">QGLViewer::CAMERA_MODE</a> shortcut key (see <a class="el" href="classQGLViewer.html#z109_0">QGLViewer::setShortcutKey()</a> and <a class="el" href="classQGLViewer.html#z93_7">QGLViewer::toggleCameraMode()</a>).
<p>
The near and far planes of the <a class="el" href="classqglviewer_1_1Camera.html">Camera</a> are determined from the <a class="el" href="classQGLViewer.html#z89_0">QGLViewer::sceneRadius()</a> and QGLViewer::sceneCenter() by the <a class="el" href="classqglviewer_1_1Camera.html#z7_0">zNear()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z7_1">zFar()</a> functions. Reasonable values on the scene extends hence have to be provided to the <a class="el" href="classQGLViewer.html">QGLViewer</a> in order for the <a class="el" href="classqglviewer_1_1Camera.html">Camera</a> to correctly display the scene. High level positioning functions can then be automated (<a class="el" href="classqglviewer_1_1Camera.html#z3_1">showEntireScene()</a>, <a class="el" href="classqglviewer_1_1Camera.html#z3_7">centerScene()</a>...). Once again, see the <a href="../mouse.html">mouse page</a> for details.
<p>
A <a class="el" href="classqglviewer_1_1Camera.html">Camera</a> holds 12 <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html">KeyFrameInterpolator</a> that can be used to save camera positions and paths. Default key binding associates these paths to the F[1-12] keys, see the <a href="../shortcuts.html">shortcut page</a> for more information.
<p>
Use <a class="el" href="classqglviewer_1_1Camera.html#z17_1">cameraCoordinatesOf()</a> ans <a class="el" href="classqglviewer_1_1Camera.html#z17_3">worldCoordinatesOf()</a> to convert to and from the <a class="el" href="classqglviewer_1_1Camera.html">Camera</a> <a class="el" href="classqglviewer_1_1Camera.html#z13_0">frame()</a> coordinate system. <a class="el" href="classqglviewer_1_1Camera.html#z19_0">projectedCoordinatesOf()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z19_2">unprojectedCoordinatesOf()</a> will convert from screen to 3D coordinates. <a class="el" href="classqglviewer_1_1Camera.html#z19_4">convertClickToLine()</a> is very useful for analytical object selection.
<p>
Stereo display is possible on machines with quad buffer capabilities (with PERSPECTIVE <a class="el" href="classqglviewer_1_1Camera.html#z5_3">type()</a> only). Test the <a href="../examples/stereoViewer.html">stereoViewer example</a> to check. 
<p>
<hr><h2>Member Enumeration Documentation</h2>
<a name="s2" doxytag="qglviewer::Camera::Type"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum Type
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The type of camera used by the <a class="el" href="classQGLViewer.html">QGLViewer</a>, set by <a class="el" href="classqglviewer_1_1Camera.html#z5_7">setType()</a>. This type will be use in <a class="el" href="classqglviewer_1_1Camera.html#z15_0">loadProjectionMatrix()</a>. <dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="classqglviewer_1_1Camera.html#z5_4">setFieldOfView</a>, <a class="el" href="classqglviewer_1_1Camera.html#z25_2">setSceneRadius</a>, type, <a class="el" href="classqglviewer_1_1Camera.html#z5_7">setType</a>, <a class="el" href="classqglviewer_1_1Camera.html#z15_0">loadProjectionMatrix</a> </dl><dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a name="s2s0" doxytag="PERSPECTIVE"></a><em>PERSPECTIVE</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="s2s1" doxytag="ORTHO"></a><em>ORTHO</em></em>&nbsp;</td><td>
</td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a name="a0" doxytag="qglviewer::Camera::Camera"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> Camera </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Default values are given to the camera parameters : sceneCenter=(0,0,0), sceneRadius=1.0, camera type = PERSPECTIVE, default stereo parameters, ....     </td>
  </tr>
</table>
<a name="a1" doxytag="qglviewer::Camera::~Camera"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ~Camera </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Virtual destructor. Current <a class="el" href="classqglviewer_1_1Camera.html#z13_0">frame()</a> is deleted.     </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a name="z11_3" doxytag="qglviewer::Camera::addKeyFrame"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void addKeyFrame </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned short&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>i</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Adds the current camera frame as a key frame to the path number <code>i</code>. This function can also be used if you simply want to save a camera point of view, as it is simply a key frame path made of one key frame.
<p>
The default shortcut for this function is Alt-F[1-12]. Set <a class="el" href="classQGLViewer.html#z109_4">QGLViewer::setKeyFrameKey()</a> and <a class="el" href="classQGLViewer.html#z109_6">QGLViewer::setAddKeyFrameStateKey()</a>.
<p>
Use <a class="el" href="classqglviewer_1_1Camera.html#z11_4">playKeyFramePath()</a> to make the camera play the key frame path (resp. restore point of view). Use <a class="el" href="classqglviewer_1_1Camera.html#z11_5">deleteKeyFramePath()</a> to clear the key frame path.
<p>
See also <a class="el" href="classqglviewer_1_1Camera.html#z11_1">keyFrameInterpolator()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z11_2">setKeyFrameInterpolator()</a> to directly define a complete path.     </td>
  </tr>
</table>
<a name="z7_4" doxytag="qglviewer::Camera::aspectRatio"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> float aspectRatio </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the currents camera aspect ratio (<a class="el" href="classqglviewer_1_1Camera.html#z7_5">screenWidth()</a> / <a class="el" href="classqglviewer_1_1Camera.html#z7_6">screenHeight()</a>), determined from the <a class="el" href="classQGLViewer.html">QGLViewer</a> window size.     </td>
  </tr>
</table>
<a name="z17_1" doxytag="qglviewer::Camera::cameraCoordinatesOf"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> cameraCoordinatesOf </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>src</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the camera frame coordinates of a point <code>src</code> defined in world coordinates. <a class="el" href="classqglviewer_1_1Camera.html#z17_3">worldCoordinatesOf()</a> performs the inverse transformation.     </td>
  </tr>
</table>
<a name="z27_0" doxytag="qglviewer::Camera::cameraPathIsEdited"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool cameraPathIsEdited </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline, protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns <code>true</code> if the camera paths are being edited in the viewer. Set by <a class="el" href="classQGLViewer.html#z87_16">QGLViewer::editCameraPath()</a> or <a class="el" href="classQGLViewer.html#z87_17">QGLViewer::toggleCameraPathEditor()</a>. See <a class="el" href="classQGLViewer.html#z87_5">QGLViewer::cameraPathIsEdited()</a> for details.     </td>
  </tr>
</table>
<a name="z3_7" doxytag="qglviewer::Camera::centerScene"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void centerScene </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Move the camera so that the <a class="el" href="classqglviewer_1_1Camera.html#z25_1">sceneCenter()</a> is projected on the center of the window. The <a class="el" href="classqglviewer_1_1Camera.html#z1_1">orientation()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z5_0">fieldOfView()</a> are unchanged.
<p>
<a class="el" href="classqglviewer_1_1MouseGrabber.html#z83_1">ManipulatedCameraFrame::mouseDoubleClickEvent()</a> calls this function after a right button double click.
<p>
See also <a class="el" href="classqglviewer_1_1Camera.html#z3_1">showEntireScene()</a>.     </td>
  </tr>
</table>
<a name="z15_8" doxytag="qglviewer::Camera::computeModelViewMatrix"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void computeModelViewMatrix </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Computes the model view matrix associated with the camera state. Called by <a class="el" href="classqglviewer_1_1Camera.html#z15_2">loadModelViewMatrix()</a> before each drawing. You need to call this function if you use the model view matrix <em>out</em> of the main drawing loop (unlikely), for a (un) <a class="el" href="classqglviewer_1_1Camera.html#z19_0">projectedCoordinatesOf()</a> or a <a class="el" href="classqglviewer_1_1Camera.html#z15_6">getModelViewMatrix()</a> for instance.     </td>
  </tr>
</table>
<a name="z19_5" doxytag="qglviewer::Camera::convertClickToLine"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void convertClickToLine </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>orig</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>dir</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function should be called by your selection function to transform a window x,y coordinate to a (world coordinates) half line, for analytical intersection process.
<p>
The origin of the half line (eye position) is stored in <code>orig</code>, while <code>dir</code> contains the properly oriented and normalized direction of the half line.
<p>
Typical usage would be: <div class="fragment"><pre> <a class="code" href="classqglviewer_1_1Camera.html#z19_4">convertClickToLine</a>(e-&gt;x(), e-&gt;y(), orig, dir);
</pre></div>
<p>
The <code>x</code> and <code>y</code> coordinates origin is in the window's <em>upper</em> left corner.
<p>
See the <a href="../examples/select.html">select example</a> for an illustration.     </td>
  </tr>
</table>
<a name="z19_4" doxytag="qglviewer::Camera::convertClickToLine"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void convertClickToLine </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>orig</em>[3], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>dir</em>[3]</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as <a class="el" href="classqglviewer_1_1Camera.html#z19_4">convertClickToLine()</a>, but the result is returned as float[3].     </td>
  </tr>
</table>
<a name="z11_5" doxytag="qglviewer::Camera::deleteKeyFramePath"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void deleteKeyFramePath </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned short&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>i</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deletes the <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html">KeyFrameInterpolator</a> of index <code>i</code>. Use <a class="el" href="classqglviewer_1_1Camera.html#z11_3">addKeyFrame()</a> to define a key frame path.
<p>
The <a class="el" href="classqglviewer_1_1Camera.html#z11_1">keyFrameInterpolator()</a> <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html#j0">KeyFrameInterpolator::interpolated()</a> signal was probably connected to the camera's viewer updateGL() slot, and you may want to disconnect it before deleting the <a class="el" href="classqglviewer_1_1Camera.html#z11_1">keyFrameInterpolator()</a>: <div class="fragment"><pre>disconnect(camera()-&gt;<a class="code" href="classqglviewer_1_1Camera.html#z11_1">keyFrameInterpolator</a>(i), SIGNAL(interpolated()), <span class="keyword">this</span>, SLOT(updateGL()));
camera()-&gt;deleteKeyFramePath(i);
</pre></div>     </td>
  </tr>
</table>
<a name="z7_8" doxytag="qglviewer::Camera::distanceToSceneCenter"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> float distanceToSceneCenter </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the distance from the camera center to <a class="el" href="classqglviewer_1_1Camera.html#z25_1">sceneCenter()</a>, <em>projected</em> along the camera Z axis. Used by <a class="el" href="classqglviewer_1_1Camera.html#z7_0">zNear()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z7_1">zFar()</a> to optimize the Z range.     </td>
  </tr>
</table>
<a name="z21_1" doxytag="qglviewer::Camera::distanceToScreen"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> float distanceToScreen </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the physical distance to screen (used for stereo mode only). Value is set using <a class="el" href="classqglviewer_1_1Camera.html#z21_5">setDistanceToScreen()</a>.     </td>
  </tr>
</table>
<a name="z21_2" doxytag="qglviewer::Camera::distanceToZeroParallaxPlane"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> float distanceToZeroParallaxPlane </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the distance to 0 parallax plane (used for stereo mode only). Value is set using <a class="el" href="classqglviewer_1_1Camera.html#z21_6">setDistanceToZeroParallaxPlane()</a>     </td>
  </tr>
</table>
<a name="z23_0" doxytag="qglviewer::Camera::domElement"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> QDomElement domElement </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const QString &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>name</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>QDomDocument &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>doc</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates an XML QDomElement that represents the <a class="el" href="classqglviewer_1_1Camera.html">Camera</a>. <code>name</code> is the name of the QDomElement tag. You need to provide the QDomDocument <code>doc</code> that will hold the resulting element.
<p>
Use <a class="el" href="classqglviewer_1_1Camera.html#z23_1">initFromDOMElement()</a> to restore the <a class="el" href="classqglviewer_1_1Camera.html">Camera</a> state from the resulting domElement.
<p>
See also <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html#z61_0">KeyFrameInterpolator::domElement()</a>, <a class="el" href="classqglviewer_1_1Frame.html#z51_0">Frame::domElement()</a>...
<p>
If you want to save the camera state in a file, use <div class="fragment"><pre>  QDomDocument doc(<span class="stringliteral">"myCAMERA"</span>);
  doc.appendChild( myCamera-&gt;domElement(<span class="stringliteral">"Camera"</span>, doc) );
  ofstream file(<span class="stringliteral">"myCamera.xml"</span>);
  file &lt;&lt; doc.toString();
</pre></div> Note that this is done automatically by <a class="el" href="classQGLViewer.html#z113_0">QGLViewer::saveToFile()</a> when a <a class="el" href="classQGLViewer.html">QGLViewer</a> is closed (default shortcut key is Escape).
<p>
Use the following code to retrieve state from the saved file: <div class="fragment"><pre> <span class="comment">// Load DOM from file</span>
 QDomDocument doc;
 QFile f(<span class="stringliteral">"myCamera.xml"</span>);
 f.open(IO_ReadOnly);
 doc.setContent(&amp;f);
 f.close();
 <span class="comment">// Parse the DOM tree</span>
 QDomElement main = doc.documentElement();
 myCamera-&gt;initFromDOMElement(main);
</pre></div>     </td>
  </tr>
</table>
<a name="z11_7" doxytag="qglviewer::Camera::drawAllPaths"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void drawAllPaths </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws the camera paths defined by the <a class="el" href="classqglviewer_1_1Camera.html#z11_1">keyFrameInterpolator()</a>. Simply calls <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html#z59_1">KeyFrameInterpolator::drawPathModifyGLState()</a> for all the defined path. See <a class="el" href="classqglviewer_1_1Camera.html#z11_3">addKeyFrame()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z11_2">setKeyFrameInterpolator()</a> to define a path.
<p>
The path color is the current <code>glColor()</code>.
<p>
<dl compact><dt><b>Attention: </b></dt><dd>
The GL state is modified by this function : see <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html#z59_1">KeyFrameInterpolator::drawPathModifyGLState()</a>. </dl>    </td>
  </tr>
</table>
<a name="z27_1" doxytag="qglviewer::Camera::editCameraPath"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void editCameraPath </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>edit</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, protected, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Starts or stops the edition of the camera paths. Called by <a class="el" href="classQGLViewer.html#z87_16">QGLViewer::editCameraPath()</a> and <a class="el" href="classQGLViewer.html#z87_17">QGLViewer::toggleCameraPathEditor()</a>. Get current value with <a class="el" href="classqglviewer_1_1Camera.html#z27_0">cameraPathIsEdited()</a>.     </td>
  </tr>
</table>
<a name="z5_0" doxytag="qglviewer::Camera::fieldOfView"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> float fieldOfView </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the vertical field of view of the camera (in radians). Value is set using <a class="el" href="classqglviewer_1_1Camera.html#z5_4">setFieldOfView()</a>, default value is pi/4 radians.     </td>
  </tr>
</table>
<a name="z3_2" doxytag="qglviewer::Camera::fitBoundingBox"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void fitBoundingBox </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>m</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>M</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Moves the camera so that the bounding box <code>m,M</code> is entirely visible, using <a class="el" href="classqglviewer_1_1Camera.html#z3_3">fitSphere()</a>.
<p>
<code>m</code> and <code>M</code> are two extremal corners of the Bounding Box.     </td>
  </tr>
</table>
<a name="z3_9" doxytag="qglviewer::Camera::fitScreenRegion"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void fitScreenRegion </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>xa</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>ya</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>xb</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>yb</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Moves the camera so that the screen region defined by (<code>xa</code>, <code>ya)</code>, (<code>xb</code>, <code>yb)</code> fits the screen. Parameters are expressed in pixels, with origin in the upper left corner.
<p>
The camera is translated (its <a class="el" href="classqglviewer_1_1Camera.html#z1_1">orientation()</a> is unchanged) so that the input rectangle is entirely visible. Since the pixel coordinates only define a <em>frustum</em> in 3D, it's the intersection of the frustum with a plane (orthogonal to the <a class="el" href="classqglviewer_1_1Camera.html#z7_11">viewDirection()</a> and passing through the <a class="el" href="classqglviewer_1_1Camera.html#z25_1">sceneCenter()</a>) that is used to define the 3D rectangle that is fitted.     </td>
  </tr>
</table>
<a name="z3_4" doxytag="qglviewer::Camera::fitSphere"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void fitSphere </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>z</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>r</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as <a class="el" href="classqglviewer_1_1Camera.html#z3_3">fitSphere()</a>, but with float parameters.     </td>
  </tr>
</table>
<a name="z3_3" doxytag="qglviewer::Camera::fitSphere"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void fitSphere </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>center</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>radius</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Moves the camera so that the sphere (<code>center</code>, <code>radius)</code> is visible and fits the window. The camera is <em>translated</em> so that the sphere fits the screen, its <a class="el" href="classqglviewer_1_1Camera.html#z1_1">orientation()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z5_0">fieldOfView()</a> are unchanged.     </td>
  </tr>
</table>
<a name="z5_2" doxytag="qglviewer::Camera::flySpeed"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> float flySpeed </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the current fly speed of the camera. This function is identical to <a class="el" href="classqglviewer_1_1ManipulatedCameraFrame.html#z63_0">ManipulatedCameraFrame::flySpeed()</a>. The <a class="el" href="classqglviewer_1_1Camera.html#z5_2">flySpeed()</a> is only meaningful when the mouse bindings are set to <a class="el" href="classQGLViewer.html#z111_0s4">QGLViewer::MOVE_FORWARD</a> or <a class="el" href="classQGLViewer.html#z111_0s6">QGLViewer::MOVE_BACKWARD</a> (see <a class="el" href="classQGLViewer.html#z111_2">QGLViewer::setMouseBinding()</a> and the <a href="../mouse.html">mouse page</a>.
<p>
Set with <a class="el" href="classqglviewer_1_1Camera.html#z5_6">setFlySpeed()</a>. Set to 0.5% of the sceneRadius in <a class="el" href="classqglviewer_1_1Camera.html#z25_2">setSceneRadius()</a>.     </td>
  </tr>
</table>
<a name="z13_0" doxytag="qglviewer::Camera::frame"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classqglviewer_1_1ManipulatedCameraFrame.html">ManipulatedCameraFrame</a>* frame </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The <a class="el" href="classqglviewer_1_1ManipulatedCameraFrame.html">ManipulatedCameraFrame</a> attached to the camera and which defines its position and orientation. See <a class="el" href="classqglviewer_1_1Camera.html#z13_1">setFrame()</a>.     </td>
  </tr>
</table>
<a name="z17_0" doxytag="qglviewer::Camera::getCameraCoordinatesOf"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void getCameraCoordinatesOf </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>src</em>[3], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>res</em>[3]</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as <a class="el" href="classqglviewer_1_1Camera.html#z17_1">cameraCoordinatesOf()</a>, but the parameters are float[3] (<code>src</code> and <code>res</code> may be identical pointers).     </td>
  </tr>
</table>
<a name="z15_7" doxytag="qglviewer::Camera::getModelViewMatrix"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void getModelViewMatrix </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">GLfloat&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>m</em>[16]          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set <code>m</code> to the current <em>camera</em> model view matrix. This modelView matrix is usually <em>not</em> the one you would get from a <code>glGetFloatv(GL_MODELVIEW_MATRIX)</code>. Instead, it only represents the <a class="el" href="classqglviewer_1_1Camera.html">Camera</a> to world coordinate system transformation matrix. As soon as you modify the <code>GL_MODELVIEW_MATRIX</code> in your <a class="el" href="classQGLViewer.html#b6">QGLViewer::draw()</a> function, the two matrices differ.
<p>
This matrix actually represents the state of the <code>GL_MODELVIEW_MATRIX</code> after <a class="el" href="classQGLViewer.html#b4">QGLViewer::preDraw()</a>, at the beginning of <a class="el" href="classQGLViewer.html#b6">QGLViewer::draw()</a>.
<p>
<dl compact><dt><b>Attention: </b></dt><dd>
If you call this function out of the classical drawing loop (<a class="el" href="classQGLViewer.html#b6">QGLViewer::draw()</a> or <a class="el" href="classQGLViewer.html#b8">QGLViewer::postDraw()</a>), you need to call <a class="el" href="classqglviewer_1_1Camera.html#z15_8">computeModelViewMatrix()</a> before this function, so that the model view matrix is properly updated.</dl><dl compact><dt><b>Attention: </b></dt><dd>
The result is an openGL 4x4 matrix, which is given in <em>column-major</em> order (see <code>glMultMatrix</code> man page for details).</dl>See also getModelViewMatrix(GLdouble m[16]) and <a class="el" href="classqglviewer_1_1Camera.html#z15_2">loadModelViewMatrix()</a>.     </td>
  </tr>
</table>
<a name="z15_6" doxytag="qglviewer::Camera::getModelViewMatrix"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void getModelViewMatrix </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">GLdouble&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>m</em>[16]          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function is provided for convenience, in case you want to work with double instead of floats, see getModelViewMatrix(GLfloat m[16]) for explanations.     </td>
  </tr>
</table>
<a name="z1_3" doxytag="qglviewer::Camera::getOrientation"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void getOrientation </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>q0</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>q1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>q2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>q3</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
float version of <a class="el" href="classqglviewer_1_1Camera.html#z1_1">orientation()</a>.     </td>
  </tr>
</table>
<a name="z7_3" doxytag="qglviewer::Camera::getOrthoWidthHeight"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void getOrthoWidthHeight </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">GLdouble &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>w</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>GLdouble &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>h</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the half width <code>w</code> and half height <code>h</code> of the camera frustum. These results are only valid when the <a class="el" href="classqglviewer_1_1Camera.html">Camera</a> is in ORTHO <a class="el" href="classqglviewer_1_1Camera.html#z5_3">type()</a>. Results are expressed in openGL units. These values are used by <a class="el" href="classqglviewer_1_1Camera.html#z15_0">loadProjectionMatrix()</a> to define the <code>glOrtho(</code> -w, w, -h, h, <a class="el" href="classqglviewer_1_1Camera.html#z7_0">zNear()</a>, <a class="el" href="classqglviewer_1_1Camera.html#z7_1">zFar()</a> ) projection matrix.     </td>
  </tr>
</table>
<a name="z1_2" doxytag="qglviewer::Camera::getPosition"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void getPosition </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>z</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as <a class="el" href="classqglviewer_1_1Camera.html#z1_0">position()</a>, but with float parameters.     </td>
  </tr>
</table>
<a name="z19_1" doxytag="qglviewer::Camera::getProjectedCoordinatesOf"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void getProjectedCoordinatesOf </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>src</em>[3], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>res</em>[3]</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
float version of <a class="el" href="classqglviewer_1_1Camera.html#z19_0">projectedCoordinatesOf()</a> (<code>src</code> and <code>res</code> may be identical pointers).     </td>
  </tr>
</table>
<a name="z15_5" doxytag="qglviewer::Camera::getProjectionMatrix"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void getProjectionMatrix </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">GLfloat&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>m</em>[16]          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set <code>m</code> to the current projection matrix. <code>m</code> is an array of 16 floats. See also getProjectionMatrix(GLdouble m[16]). <dl compact><dt><b>Attention: </b></dt><dd>
<code>glMatrixMode</code> is set to <code>GL_PROJECTION</code>. </dl>    </td>
  </tr>
</table>
<a name="z15_4" doxytag="qglviewer::Camera::getProjectionMatrix"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void getProjectionMatrix </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">GLdouble&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>m</em>[16]          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function is provided for convenience, in case you want to work with double instead of floats, see getProjectionMatrix(GLfloat m[16]) for explanations.     </td>
  </tr>
</table>
<a name="z9_1" doxytag="qglviewer::Camera::getRevolveAroundPoint"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void getRevolveAroundPoint </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>z</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
float version of <a class="el" href="classqglviewer_1_1Camera.html#z9_0">revolveAroundPoint()</a>.     </td>
  </tr>
</table>
<a name="z19_3" doxytag="qglviewer::Camera::getUnprojectedCoordinatesOf"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void getUnprojectedCoordinatesOf </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>src</em>[3], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>res</em>[3]</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as <a class="el" href="classqglviewer_1_1Camera.html#z19_3">getUnprojectedCoordinatesOf()</a>, but with float parameters (<code>src</code> and <code>res</code> may be identical pointers).     </td>
  </tr>
</table>
<a name="z7_10" doxytag="qglviewer::Camera::getUpVector"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void getUpVector </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>z</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as <a class="el" href="classqglviewer_1_1Camera.html#z7_9">upVector()</a>, but with float parameters.     </td>
  </tr>
</table>
<a name="z7_12" doxytag="qglviewer::Camera::getViewDirection"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void getViewDirection </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>z</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="z7_15" doxytag="qglviewer::Camera::getViewport"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void getViewport </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">GLint&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>viewport</em>[4]          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Fills <code>viewport</code> with current camera viewport. This function is mainly used in conjunction with <code>gluProject</code>, which requires such a viewport. Returned values are simply (0, 0, <a class="el" href="classqglviewer_1_1Camera.html#z7_5">screenWidth()</a>, <a class="el" href="classqglviewer_1_1Camera.html#z7_6">screenHeight()</a>).     </td>
  </tr>
</table>
<a name="z17_2" doxytag="qglviewer::Camera::getWorldCoordinatesOf"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void getWorldCoordinatesOf </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>src</em>[3], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>res</em>[3]</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as <a class="el" href="classqglviewer_1_1Camera.html#z17_3">worldCoordinatesOf()</a>, but the parameters are float[3] (<code>src</code> and <code>res</code> may be identical pointers).     </td>
  </tr>
</table>
<a name="z5_1" doxytag="qglviewer::Camera::horizontalFieldOfView"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> float horizontalFieldOfView </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the horizontal (X camera frame direction) field of view used by the camera (in radians). Value is set using <a class="el" href="classqglviewer_1_1Camera.html#z5_5">setHorizontalFieldOfView()</a> or <a class="el" href="classqglviewer_1_1Camera.html#z5_4">setFieldOfView()</a>. The values are always linked by : <div class="fragment"><pre>    <a class="code" href="classqglviewer_1_1Camera.html#z5_1">horizontalFieldOfView</a>() = 2.0 * atan ( tan(<a class="code" href="classqglviewer_1_1Camera.html#z5_0">fieldOfView</a>()/2.0) * <a class="code" href="classqglviewer_1_1Camera.html#z7_4">aspectRatio</a>() ).
</pre></div>     </td>
  </tr>
</table>
<a name="z23_1" doxytag="qglviewer::Camera::initFromDOMElement"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void initFromDOMElement </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const QDomElement &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>de</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Restore the <a class="el" href="classqglviewer_1_1Camera.html">Camera</a> state from a QDomElement created by <a class="el" href="classqglviewer_1_1Camera.html#z23_0">domElement()</a>. See also <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html#z61_1">KeyFrameInterpolator::initFromDOMElement()</a>, <a class="el" href="classqglviewer_1_1Frame.html#z51_1">Frame::initFromDOMElement()</a>.     </td>
  </tr>
</table>
<a name="z3_12" doxytag="qglviewer::Camera::interpolateToFitScene"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void interpolateToFitScene </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inperpolates the camera position on a one second <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html">KeyFrameInterpolator</a> path stating from the current position, so that at the end the entire scene is visible and fits in screen (see <a class="el" href="classqglviewer_1_1Camera.html#z3_1">showEntireScene()</a>). See also <a class="el" href="classqglviewer_1_1Camera.html#z3_11">interpolateToZoomOnPixel()</a>.
<p>
This function is called when you press the middle mouse button and then double click the right button. See <a href="../mouse.html">mouse page</a> for details.     </td>
  </tr>
</table>
<a name="z3_11" doxytag="qglviewer::Camera::interpolateToZoomOnPixel"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void interpolateToZoomOnPixel </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>y</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Make the camera zoom on the selected pixel (if an object is actually drawn in this pixel, see <a class="el" href="classqglviewer_1_1Camera.html#z7_13">pointUnderPixel()</a>). A <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html">KeyFrameInterpolator</a> is created and animates the camera on a one second path that brings the camera closer to the selected pixel. See also <a class="el" href="classqglviewer_1_1Camera.html#z3_12">interpolateToFitScene()</a>.
<p>
This function is called when you press the middle mouse button and then double click the left button. See <a href="../mouse.html">mouse page</a> for details.     </td>
  </tr>
</table>
<a name="z21_0" doxytag="qglviewer::Camera::IODist"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> float IODist </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the inter-ocular distance used for stereo (in meters). Value set using <a class="el" href="classqglviewer_1_1Camera.html#z21_4">setIODist()</a>     </td>
  </tr>
</table>
<a name="z7_14" doxytag="qglviewer::Camera::isManipulated"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool isManipulated </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<code>true</code> when the camera is being manipulated with the mouse. Useful for switching to fast draw mode. See <a class="el" href="classQGLViewer.html#b7">QGLViewer::fastDraw()</a>.     </td>
  </tr>
</table>
<a name="z11_1" doxytag="qglviewer::Camera::keyFrameInterpolator"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html">KeyFrameInterpolator</a> * keyFrameInterpolator </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned short&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>i</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the current <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html">KeyFrameInterpolator</a> that defines the camera path number <code>i</code>.
<p>
If the path is not defined for this index, the method returns a <code>NULL</code> pointer.
<p>
The <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html#j0">KeyFrameInterpolator::interpolated()</a> signal of this <a class="el" href="classqglviewer_1_1Camera.html#z11_1">keyFrameInterpolator()</a> should be connected to any object that should be notified when the frame is interpolated. The camera's associated viewer (if any) should especially be connected. See the <a class="el" href="classqglviewer_1_1Camera.html#z11_2">setKeyFrameInterpolator()</a> documentation.
<p>
<dl compact><dt><b>Attention: </b></dt><dd>
index must be in the range 0..<a class="el" href="classqglviewer_1_1Camera.html#z11_0">nbPaths()</a>-1. </dl>    </td>
  </tr>
</table>
<a name="z15_2" doxytag="qglviewer::Camera::loadModelViewMatrix"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void loadModelViewMatrix </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>reset</em> = true          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Loads the current camera GL_MODELVIEW matrix.
<p>
When <code>reset</code> is <code>true</code> (default), it clears the previous projection matrix by calling <code>glLoadMatrixd</code>. Setting <code>reset</code> to <code>false</code> simply calls <code>glMultMatrixd</code> (might be useful for some applications).
<p>
<a class="el" href="classqglviewer_1_1Camera.html#z15_6">getModelViewMatrix()</a> returns the current 4x4 model view matrix.
<p>
<dl compact><dt><b>Attention: </b></dt><dd>
glMatrixMode is set to GL_MODELVIEW</dl><dl compact><dt><b>Attention: </b></dt><dd>
makeCurrent() must be called by every calling method if this function is used out of the main drawing loop (i.e. not in <a class="el" href="classQGLViewer.html#b6">QGLViewer::draw()</a> or in <a class="el" href="classQGLViewer.html#b4">QGLViewer::preDraw()</a>). </dl>    </td>
  </tr>
</table>
<a name="z15_3" doxytag="qglviewer::Camera::loadModelViewMatrixStereo"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void loadModelViewMatrixStereo </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>leftBuffer</em> = true          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Loads the GL_MODELVIEW matrix for stereo mode. It clears the previous modelview matrix by calling <code>glLoadIdentity</code> before setting the matrix. When <code>leftBuffer</code> is <code>true</code> (resp. false), it performs a left (resp. right) buffer translation by modifying the translation term directly in the modelView matrix.
<p>
<dl compact><dt><b>Attention: </b></dt><dd>
glMatrixMode is set to <code>GL_MODELVIEW</code></dl><dl compact><dt><b>Attention: </b></dt><dd>
makeCurrent() must be called by every calling method if this function is used out of the main drawing loop (i.e. not in <a class="el" href="classQGLViewer.html#b6">QGLViewer::draw()</a> or in <a class="el" href="classQGLViewer.html#b4">QGLViewer::preDraw()</a>).. </dl>    </td>
  </tr>
</table>
<a name="z15_0" doxytag="qglviewer::Camera::loadProjectionMatrix"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void loadProjectionMatrix </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>reset</em> = true          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Load the current camera GL_PROJECTION matrix. Default method set camera according to <a class="el" href="classqglviewer_1_1Camera.html#z5_0">fieldOfView()</a>, and window aspect ratio in PERSPECTIVE <a class="el" href="classqglviewer_1_1Camera.html#z5_3">type()</a>. See <a class="el" href="classqglviewer_1_1Camera.html#z7_3">getOrthoWidthHeight()</a> for ORTHO <a class="el" href="classqglviewer_1_1Camera.html#z5_3">type()</a>.
<p>
Uses <a class="el" href="classqglviewer_1_1Camera.html#z7_0">zNear()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z7_1">zFar()</a> which are determined from <a class="el" href="classqglviewer_1_1Camera.html#z25_0">sceneRadius()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z25_1">sceneCenter()</a> so that they best fit the scene size.
<p>
<a class="el" href="classqglviewer_1_1Camera.html">Camera</a> type is returned by <a class="el" href="classqglviewer_1_1Camera.html#z5_3">type()</a>, and is set with <a class="el" href="classqglviewer_1_1Camera.html#z5_7">setType()</a>.
<p>
When <code>reset</code> is <code>true</code> (default), it clears the previous projection matrix by calling <code>glLoadIdentity</code> before setting the matrix. Setting <code>reset</code> to <code>false</code> is usefull for GL_SELECT mode, to combine the matrix with a picking matrix.
<p>
<a class="el" href="classqglviewer_1_1Camera.html#z15_4">getProjectionMatrix()</a> returns the 4x4 projection matrix.
<p>
<dl compact><dt><b>Attention: </b></dt><dd>
glMatrixMode is set to GL_PROJECTION <dd>
makeCurrent() must be called by every calling method. </dl>    </td>
  </tr>
</table>
<a name="z15_1" doxytag="qglviewer::Camera::loadProjectionMatrixStereo"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void loadProjectionMatrixStereo </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>leftBuffer</em> = true          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Load the current camera GL_PROJECTION matrix for Stereo mode. Only PERSPECTIVE camera <a class="el" href="classqglviewer_1_1Camera.html#z5_3">type()</a> case is handled.
<p>
Uses <a class="el" href="classqglviewer_1_1Camera.html#z7_0">zNear()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z7_1">zFar()</a> which are determined from <a class="el" href="classqglviewer_1_1Camera.html#z25_0">sceneRadius()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z25_1">sceneCenter()</a> so that they best fit the scene size.
<p>
Uses <a class="el" href="classqglviewer_1_1Camera.html#z21_2">distanceToZeroParallaxPlane()</a>, <a class="el" href="classqglviewer_1_1Camera.html#z21_0">IODist()</a>, and <a class="el" href="classqglviewer_1_1Camera.html#z21_3">physicalScreenWidth()</a> to compute cameras offset for stereovision, as well as asymmetric frustums
<p>
<a class="el" href="classqglviewer_1_1Camera.html">Camera</a> type is returned by <a class="el" href="classqglviewer_1_1Camera.html#z5_3">type()</a>, and is set with <a class="el" href="classqglviewer_1_1Camera.html#z5_7">setType()</a>.
<p>
When <code>leftBuffer</code> is <code>true</code> (default), computes the projection matrix for left camera (right camera otherwise).
<p>
<a class="el" href="classqglviewer_1_1Camera.html#z15_4">getProjectionMatrix()</a> will always return the 4x4 <b>mono</b> projection matrix. <dl compact><dt><b>Attention: </b></dt><dd>
glMatrixMode is set to GL_PROJECTION <dd>
makeCurrent() must be called by every calling method. </dl>    </td>
  </tr>
</table>
<a name="z3_6" doxytag="qglviewer::Camera::lookAt"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void lookAt </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>z</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as <a class="el" href="classqglviewer_1_1Camera.html#z3_5">lookAt()</a>, but with float parameters.     </td>
  </tr>
</table>
<a name="z3_5" doxytag="qglviewer::Camera::lookAt"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void lookAt </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>target</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the camera orientation, so that it looks at point <code>target</code> (defined in the world coordinate system). The camera position is not modified. The camera is rotated so that the horizon is preserved. See also <a class="el" href="classqglviewer_1_1Camera.html#z1_6">setOrientation()</a>, <a class="el" href="classqglviewer_1_1Camera.html#z3_1">showEntireScene()</a>, <a class="el" href="classqglviewer_1_1Camera.html#z3_8">setUpVector()</a>, <a class="el" href="classqglviewer_1_1Camera.html#z3_3">fitSphere()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z3_2">fitBoundingBox()</a>.     </td>
  </tr>
</table>
<a name="z11_0" doxytag="qglviewer::Camera::nbPaths"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int nbPaths </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the number of camera paths that can be defined. This is the maximum number of <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html">KeyFrameInterpolator</a> that can be saved (index range is 0..<code>nbPaths()-1)</code>, but some of them may not be <em>defined</em> (<a class="el" href="classqglviewer_1_1Camera.html#z11_1">keyFrameInterpolator()</a> will return <code>NULL)</code>.     </td>
  </tr>
</table>
<a name="z1_1" doxytag="qglviewer::Camera::orientation"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classqglviewer_1_1Quaternion.html">Quaternion</a> orientation </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the camera current orientation, defined in the world coordinate system. Actually returns <code>frame()-&gt;orientation()</code>. Use <a class="el" href="classqglviewer_1_1Camera.html#z1_6">setOrientation()</a>, <a class="el" href="classqglviewer_1_1Camera.html#z3_8">setUpVector()</a> or <a class="el" href="classqglviewer_1_1Camera.html#z3_5">lookAt()</a> to set the camera orientation.     </td>
  </tr>
</table>
<a name="z21_3" doxytag="qglviewer::Camera::physicalScreenWidth"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> float physicalScreenWidth </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the physical screen width (used for stereo mode only). Value is set using <a class="el" href="classqglviewer_1_1Camera.html#z21_7">setPhysicalScreenWidth()</a>     </td>
  </tr>
</table>
<a name="z7_7" doxytag="qglviewer::Camera::pixelGLRatio"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> float pixelGLRatio </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>pos</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the pixel to GL unit ratio. A line of <code>n</code> * <a class="el" href="classqglviewer_1_1Camera.html#z7_7">pixelGLRatio()</a> GL units, located at position <code>pos</code> in the world coordinates system, will be projected with a length of <code>n</code> pixels on screen. Use this function to scale objects so that they have a constant pixel size on screen.
<p>
The following code will draw a 20 pixel line, starting at <a class="el" href="classqglviewer_1_1Camera.html#z25_1">sceneCenter()</a> and always directed along the screen vertical direction. <div class="fragment"><pre>  glBegin(GL_LINES);
  glVertex3fv(<a class="code" href="classqglviewer_1_1Camera.html#z25_1">sceneCenter</a>().address());
  glVertex3fv((<a class="code" href="classqglviewer_1_1Camera.html#z25_1">sceneCenter</a>() + 20*<a class="code" href="classqglviewer_1_1Camera.html#z7_7">pixelGLRatio</a>(<a class="code" href="classqglviewer_1_1Camera.html#z25_1">sceneCenter</a>())*<a class="code" href="classqglviewer_1_1Camera.html#z7_9">upVector</a>()).address());
  glEnd();
</pre></div>
<p>
<dl compact><dt><b>Attention: </b></dt><dd>
The resulting value is only valid for a given <a class="el" href="classqglviewer_1_1Camera.html">Camera</a> and a given <code>pos</code>. It also naturally depends on the current screen height (see <a class="el" href="classqglviewer_1_1Camera.html#z7_6">screenHeight()</a>). </dl>    </td>
  </tr>
</table>
<a name="z11_4" doxytag="qglviewer::Camera::playKeyFramePath"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void playKeyFramePath </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned short&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>i</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Make the camera follow the key frame path number <code>i</code>. The key Frames are defined using <a class="el" href="classqglviewer_1_1Camera.html#z11_3">addKeyFrame()</a>. Use <a class="el" href="classqglviewer_1_1Camera.html#z11_5">deleteKeyFramePath()</a> to clear a path. This function silently ignores undefined (empty) paths.
<p>
The default shortcut for this function is F[1-12]. Set <a class="el" href="classQGLViewer.html#z109_4">QGLViewer::setKeyFrameKey()</a> and <a class="el" href="classQGLViewer.html#z109_8">QGLViewer::setPlayKeyFramePathStateKey()</a>.
<p>
See also <a class="el" href="classqglviewer_1_1Camera.html#z11_1">keyFrameInterpolator()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z11_2">setKeyFrameInterpolator()</a> to directly define a complete path.     </td>
  </tr>
</table>
<a name="z7_13" doxytag="qglviewer::Camera::pointUnderPixel"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> pointUnderPixel </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>found</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the coordinates of the 3D point located at pixel (x,y) on screen (origin in the <em>upper</em> left corner). Calls a <code>glReadPixel</code> to get the pixel depth and applies an <a class="el" href="classqglviewer_1_1Camera.html#z19_2">unprojectedCoordinatesOf()</a> to the result. <code>found</code> indicates whether a point was found or not (i.e. background pixel, result's depth is <a class="el" href="classqglviewer_1_1Camera.html#z7_1">zFar()</a> in that case).
<p>
<dl compact><dt><b>Attention: </b></dt><dd>
The precision of the ZBuffer highly depends on how tight to your scene are the <a class="el" href="classqglviewer_1_1Camera.html#z7_0">zNear()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z7_1">zFar()</a> values. Imprecision may result along the viewing direction otherwise. See <a class="el" href="classQGLViewer.html#z89_6">QGLViewer::setSceneCenter()</a>, <a class="el" href="classQGLViewer.html#z89_5">QGLViewer::setSceneRadius()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z7_16">setZNearCoef()</a>. </dl>    </td>
  </tr>
</table>
<a name="z1_0" doxytag="qglviewer::Camera::position"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> position </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the camera position (the eye), defined in the world coordinate system. Use <a class="el" href="classqglviewer_1_1Camera.html#z1_4">setPosition()</a> to set the camera position. Other convenient functions are <a class="el" href="classqglviewer_1_1Camera.html#z3_1">showEntireScene()</a>, <a class="el" href="classqglviewer_1_1Camera.html#z3_2">fitBoundingBox()</a> or <a class="el" href="classqglviewer_1_1Camera.html#z3_3">fitSphere()</a>. Actually returns <code>frame()-&gt;position()</code>.     </td>
  </tr>
</table>
<a name="z19_0" doxytag="qglviewer::Camera::projectedCoordinatesOf"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> projectedCoordinatesOf </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>src</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the screen projected coordinates of a point <code>src</code> defined in the world coordinate system. See the <code>gluProject</code> man page for details. The x and y returned values are expressed in pixel, (0,0) being the <em>upper</em> left corner of the window.
<p>
This method is not computationally optimized. If you call it several times with no change in the matrices, you should buffer the entire projection matrix (modelview, projection and then viewport) to speed-up the queries. See the <code>gluProject</code> man page for details.
<p>
<a class="el" href="classqglviewer_1_1Camera.html#z19_2">unprojectedCoordinatesOf()</a> performs the inverse transformation.
<p>
<dl compact><dt><b>Attention: </b></dt><dd>
When used in conjunction with <a class="el" href="classQGLViewer.html#z95_2">QGLViewer::startScreenCoordinatesSystem()</a>, the computations of the projected coordinates must be done <em>before</em> entering the screen coordinate mode, as the camera matrix is no longer a 3D projection in this mode. See the <a href="../examples/screenCoordSystem.html">screenCoordSystem</a> example.</dl><dl compact><dt><b>Attention: </b></dt><dd>
If not used in <a class="el" href="classQGLViewer.html#b6">QGLViewer::draw()</a> or similar functions, call makeCurrent() and <a class="el" href="classqglviewer_1_1Camera.html#z15_8">computeModelViewMatrix()</a> before calling this function. </dl>    </td>
  </tr>
</table>
<a name="z11_6" doxytag="qglviewer::Camera::resetKeyFramePath"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void resetKeyFramePath </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned short&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>i</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
If this keyFrame path is <em>not</em> being played (see <a class="el" href="classqglviewer_1_1Camera.html#z11_4">playKeyFramePath()</a> ), reset it to is its starting position (see <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html#z57_3">KeyFrameInterpolator::resetInterpolation()</a>). If the path is played, simply stop interpolation.     </td>
  </tr>
</table>
<a name="z9_0" doxytag="qglviewer::Camera::revolveAroundPoint"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> revolveAroundPoint </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
With <a class="el" href="classQGLViewer.html#z111_0s1">QGLViewer::ROTATE</a> mouse binding, this is the point the camera revolves around (defined in world coordinate system). Default value is the <a class="el" href="classqglviewer_1_1Camera.html#z25_1">sceneCenter()</a>. <dl compact><dt><b>Attention: </b></dt><dd>
<a class="el" href="classqglviewer_1_1Camera.html#z25_4">setSceneCenter()</a> changes this value. </dl>    </td>
  </tr>
</table>
<a name="z25_1" doxytag="qglviewer::Camera::sceneCenter"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> sceneCenter </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the position of the scene center. This value is set <a class="el" href="classqglviewer_1_1Camera.html#z25_4">setSceneCenter()</a>, which is called by <a class="el" href="classQGLViewer.html#z89_6">QGLViewer::setSceneCenter()</a>. Default is 0,0,0 (world origin).     </td>
  </tr>
</table>
<a name="z25_0" doxytag="qglviewer::Camera::sceneRadius"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> float sceneRadius </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the scene radius used by the camera. Used to set the camera near and far planes (see <a class="el" href="classqglviewer_1_1Camera.html#z7_0">zNear()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z7_1">zFar()</a>). This value is modifed by <a class="el" href="classQGLViewer.html#z89_5">QGLViewer::setSceneRadius()</a>, which simply calls <a class="el" href="classqglviewer_1_1Camera.html#z25_2">setSceneRadius()</a>.     </td>
  </tr>
</table>
<a name="z7_6" doxytag="qglviewer::Camera::screenHeight"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int screenHeight </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the current height (in pixels) of the camera screen. See also QGLWidget::height().     </td>
  </tr>
</table>
<a name="z7_5" doxytag="qglviewer::Camera::screenWidth"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int screenWidth </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the current width (in pixels) of the camera screen. See also QGLWidget::width()     </td>
  </tr>
</table>
<a name="z7_17" doxytag="qglviewer::Camera::setAspectRatio"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setAspectRatio </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>ar</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Defines the camera <a class="el" href="classqglviewer_1_1Camera.html#z7_4">aspectRatio()</a>.
<p>
<dl compact><dt><b>Attention: </b></dt><dd>
When a <a class="el" href="classqglviewer_1_1Camera.html">Camera</a> is attached to a <a class="el" href="classQGLViewer.html">QGLViewer</a> (using <a class="el" href="classQGLViewer.html#z91_2">QGLViewer::setCamera()</a>), the <a class="el" href="classqglviewer_1_1Camera.html">Camera</a> <a class="el" href="classqglviewer_1_1Camera.html#z7_5">screenWidth()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z7_6">screenHeight()</a> (and hence <a class="el" href="classqglviewer_1_1Camera.html#z7_4">aspectRatio()</a>) are automatically set and updated from the <a class="el" href="classQGLViewer.html">QGLViewer</a> window dimensions. This function then becomes useless and non effective.</dl>However, when the <a class="el" href="classqglviewer_1_1Camera.html">Camera</a> positioning functions are used to create a shadow map, as seen from a virtual light source, this function is needed, since the <a class="el" href="classqglviewer_1_1Camera.html#z7_4">aspectRatio()</a> of the <a class="el" href="classqglviewer_1_1Camera.html">Camera</a> is used to create the projection matrix (see <a class="el" href="classqglviewer_1_1Camera.html#z15_0">loadProjectionMatrix()</a>). See the (soon available) shadowMap example for an illustration.
<p>
<dl compact><dt><b>Note: </b></dt><dd>
If you need an <a class="el" href="classqglviewer_1_1Camera.html#z7_4">aspectRatio()</a> that does not correspond to your viewer window dimensions, overload <a class="el" href="classqglviewer_1_1Camera.html#z15_0">loadProjectionMatrix()</a> or multiply the created GL_PROJECTION matrix by a scaled diagonal matrix in your <a class="el" href="classQGLViewer.html#b6">QGLViewer::draw()</a> function. </dl>    </td>
  </tr>
</table>
<a name="z1_9" doxytag="qglviewer::Camera::setCameraFromProjectionMatrix"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setCameraFromProjectionMatrix </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const float *const&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>m</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<em>m</em> is the projection matrix as used in vision algorithm. It has 3 lines and 4 columns. It transforms a point in the world homogeneous coordinate system (4 coordinates: <em>sx</em>, <em>sy</em>, <em>sz</em> and <em>s)</em> in a point in the screen homogeneous coordinate system (3 coordinates: <em>sx</em>, <em>sy</em>, and <em>s</em>, where <em>x</em> and <em>y</em> are the pixel coordinates on the screen).
<p>
<em>m</em> is a pointer to the elements of the matrix ordered in line major order. If you define your matrix as a <code>float</code> <code>matrix[3][4]</code>, you should call : <code>setCameraFromProjectionMatrix(&amp;(matrix[0][0]))</code>;
<p>
This code was written by Sylvain Paris (<a href="mailto:Sylvain.Paris@imag.fr">Sylvain.Paris@imag.fr</a>).     </td>
  </tr>
</table>
<a name="z21_5" doxytag="qglviewer::Camera::setDistanceToScreen"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setDistanceToScreen </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>dts</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Defines the distance in real world between the observer eyes and the screen -monitor or projection wall- in meters. Default value is 0.5m.
<p>
<a class="el" href="classqglviewer_1_1Camera.html#z15_1">loadProjectionMatrixStereo()</a> uses this value to define the camera offset and frustum.
<p>
<a class="el" href="classqglviewer_1_1Camera.html#z21_1">distanceToScreen()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z21_2">distanceToZeroParallaxPlane()</a> represent the same distance. <a class="el" href="classqglviewer_1_1Camera.html#z21_1">distanceToScreen()</a> is expressed in physical real units, while <a class="el" href="classqglviewer_1_1Camera.html#z21_2">distanceToZeroParallaxPlane()</a> is expressed in openGL virtual world units. Use their ratio to convert distances between these worlds.     </td>
  </tr>
</table>
<a name="z21_6" doxytag="qglviewer::Camera::setDistanceToZeroParallaxPlane"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setDistanceToZeroParallaxPlane </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>dtz</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Defines the distance in virtual world between the viewpoint and the plane where the horizontal parallax is null, that is to say where the stereo left and right images are superimposed. This distance is also referred as the focus distance.
<p>
<a class="el" href="classqglviewer_1_1Camera.html#z15_1">loadProjectionMatrixStereo()</a> uses this value to define the camera offset and frustum.
<p>
<a class="el" href="classqglviewer_1_1Camera.html#z21_1">distanceToScreen()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z21_2">distanceToZeroParallaxPlane()</a> represent the same distance. <a class="el" href="classqglviewer_1_1Camera.html#z21_1">distanceToScreen()</a> is expressed in physical real units, while <a class="el" href="classqglviewer_1_1Camera.html#z21_2">distanceToZeroParallaxPlane()</a> is expressed in openGL virtual world units. Use their ratio to convert distances between these worlds.
<p>
<dl compact><dt><b>Attention: </b></dt><dd>
This value is modified by <a class="el" href="classQGLViewer.html#z89_5">QGLViewer::setSceneRadius()</a>, <a class="el" href="classqglviewer_1_1Camera.html#z25_2">setSceneRadius()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z5_4">setFieldOfView()</a>. When one of these values is modified, <a class="el" href="classqglviewer_1_1Camera.html#z21_2">distanceToZeroParallaxPlane()</a> is set to <a class="el" href="classqglviewer_1_1Camera.html#z25_0">sceneRadius()</a> / tan(<a class="el" href="classqglviewer_1_1Camera.html#z5_0">fieldOfView()</a>/2). </dl>    </td>
  </tr>
</table>
<a name="z5_4" doxytag="qglviewer::Camera::setFieldOfView"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setFieldOfView </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>f</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Defines the vertical field of view of the camera (in radians). Also used to fit the scene and mouse translations. <a class="el" href="classqglviewer_1_1Camera.html#z5_0">fieldOfView()</a> returns the current value. The default value is pi/4 radians. <a class="el" href="classqglviewer_1_1Camera.html#z15_0">loadProjectionMatrix()</a> uses this value to define the camera.
<p>
The field of view corresponds the one used in <code>gluPerspective</code> (see manual). It sets the Y (vertical) aperture of the camera. The X (horizontal) angle is inferred from the window aspect ratio (see <a class="el" href="classqglviewer_1_1Camera.html#z7_4">aspectRatio()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z5_1">horizontalFieldOfView()</a>).
<p>
Use <a class="el" href="classqglviewer_1_1Camera.html#z3_10">setFOVToFitScene()</a> to adapt the <a class="el" href="classqglviewer_1_1Camera.html#z5_0">fieldOfView()</a>. This is not the normal way of zooming in or out. All the other positioning camera function (<a class="el" href="classqglviewer_1_1Camera.html#z3_1">showEntireScene()</a>, <a class="el" href="classqglviewer_1_1Camera.html#z3_3">fitSphere()</a>...) <em>move</em> the camera instead of changing its <a class="el" href="classqglviewer_1_1Camera.html#z5_0">fieldOfView()</a>.
<p>
<a class="el" href="classqglviewer_1_1Camera.html#z21_2">distanceToZeroParallaxPlane()</a> is set to <a class="el" href="classqglviewer_1_1Camera.html#z25_0">sceneRadius()</a> / tan(<a class="el" href="classqglviewer_1_1Camera.html#z5_0">fieldOfView()</a>/2) (used only for stereo mode, see <a class="el" href="classQGLViewer.html#z93_5">QGLViewer::setStereoDisplay()</a>, <a class="el" href="classqglviewer_1_1Camera.html#z25_2">setSceneRadius()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z21_6">setDistanceToZeroParallaxPlane()</a>).     </td>
  </tr>
</table>
<a name="z5_6" doxytag="qglviewer::Camera::setFlySpeed"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setFlySpeed </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>s</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
When the camera associated mouse action is <a class="el" href="classQGLViewer.html#z111_0s4">QGLViewer::MOVE_FORWARD</a> or <a class="el" href="classQGLViewer.html#z111_0s6">QGLViewer::MOVE_BACKWARD</a>, tunes the speed of the displacement. Current value is given by <a class="el" href="classqglviewer_1_1Camera.html#z5_2">flySpeed()</a>. See the <a href="../mouse.html">mouse page</a> for details.
<p>
<dl compact><dt><b>Attention: </b></dt><dd>
This value is modified by <a class="el" href="classqglviewer_1_1Camera.html#z25_2">setSceneRadius()</a>. </dl>    </td>
  </tr>
</table>
<a name="z3_10" doxytag="qglviewer::Camera::setFOVToFitScene"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setFOVToFitScene </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Change the camera <a class="el" href="classqglviewer_1_1Camera.html#z5_0">fieldOfView()</a> so that the entire scene (defined by <a class="el" href="classQGLViewer.html">QGLViewer</a>;;<a class="el" href="classqglviewer_1_1Camera.html#z25_1">sceneCenter()</a> and <a class="el" href="classQGLViewer.html#z89_0">QGLViewer::sceneRadius()</a>) would be visible from the current camera <a class="el" href="classqglviewer_1_1Camera.html#z1_0">position()</a>. The <a class="el" href="classqglviewer_1_1Camera.html#z1_0">position()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z1_1">orientation()</a> of the camera are not modified and you have to properly orientate the camera in order to actually <em>see</em> the scene (see <a class="el" href="classqglviewer_1_1Camera.html#z3_5">lookAt()</a>). See also <a class="el" href="classqglviewer_1_1Camera.html#z3_1">showEntireScene()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z3_3">fitSphere()</a>.
<p>
This function is especially useful for <em>shadow</em> <em>maps</em> computation. Use the camera positioning tools (<a class="el" href="classqglviewer_1_1Camera.html#z1_4">setPosition()</a>, <a class="el" href="classqglviewer_1_1Camera.html#z3_5">lookAt()</a>) to position a camera at the light position. Use <a class="el" href="classqglviewer_1_1Camera.html#z3_10">setFOVToFitScene()</a> to define an optimal <a class="el" href="classqglviewer_1_1Camera.html#z5_0">fieldOfView()</a> for this camera, so that the shadow map resolution is optimally used.
<p>
<div class="fragment"><pre>  <span class="comment">// The light camera needs size hints in order to optimize FOV</span>
  light_camera-&gt;setSceneRadius(<a class="code" href="classqglviewer_1_1Camera.html#z25_0">sceneRadius</a>());
  light_camera-&gt;setSceneCenter(<a class="code" href="classqglviewer_1_1Camera.html#z25_1">sceneCenter</a>());

  <span class="comment">// Place the light camera.</span>
  light_camera-&gt;setPosition(light_frame-&gt;position());
  light_camera-&gt;lookAt(<a class="code" href="classqglviewer_1_1Camera.html#z25_1">sceneCenter</a>());
  light_camera-&gt;setFOVToFitScene();
</pre></div>
<p>
Use a viewer <a class="el" href="classQGLViewer.html#z95_8">QGLViewer::displayZBuffer()</a> function to actually see the computed shadow map. See the shadowMap contribution example for a practical implementation.
<p>
<dl compact><dt><b>Attention: </b></dt><dd>
The <a class="el" href="classqglviewer_1_1Camera.html#z5_0">fieldOfView()</a> is clamped to M_PI/2.0. It happens when the camera is at a distance lower than sqrt(2) * <a class="el" href="classqglviewer_1_1Camera.html#z25_0">sceneRadius()</a> from the <a class="el" href="classqglviewer_1_1Camera.html#z25_1">sceneCenter()</a>. This behavior is especially useful for shadow map computation in order to optimize the shadow map resolution, although it may miss some parts of the scene. </dl>    </td>
  </tr>
</table>
<a name="z13_1" doxytag="qglviewer::Camera::setFrame"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setFrame </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classqglviewer_1_1ManipulatedCameraFrame.html">ManipulatedCameraFrame</a> *const&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>f</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Changes the <a class="el" href="classqglviewer_1_1ManipulatedCameraFrame.html">ManipulatedCameraFrame</a> that defines the position and orientation of the camera. If you simply want to move the camera, use <a class="el" href="classqglviewer_1_1Camera.html#z1_4">setPosition()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z1_6">setOrientation()</a> or one of the camera positioning functions : <a class="el" href="classqglviewer_1_1Camera.html#z3_5">lookAt()</a>, <a class="el" href="classqglviewer_1_1Camera.html#z3_3">fitSphere()</a>, <a class="el" href="classqglviewer_1_1Camera.html#z3_2">fitBoundingBox()</a>, <a class="el" href="classqglviewer_1_1Camera.html#z3_1">showEntireScene()</a>...
<p>
If you want to save camera positions, there's no real need to call this function either. Use <a class="el" href="classqglviewer_1_1Camera.html#z11_3">addKeyFrame()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z11_4">playKeyFramePath()</a> for this.
<p>
This function is actually mainly useful if you derive the <a class="el" href="classqglviewer_1_1ManipulatedCameraFrame.html">ManipulatedCameraFrame</a> class and want to use an instance of your new class to move the camera.
<p>
A <code>NULL</code> frame pointer will silently be ignored. The calling function is responsible for deleting the previous <a class="el" href="classqglviewer_1_1Camera.html#z13_0">frame()</a> pointer if needed in order to prevent memory leaks : <div class="fragment"><pre><span class="keyword">delete</span> camera()-&gt;frame();
camera()-&gt;setFrame(myManipulatedCameraFrame());
</pre></div>     </td>
  </tr>
</table>
<a name="z5_5" doxytag="qglviewer::Camera::setHorizontalFieldOfView"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setHorizontalFieldOfView </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>hfov</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Defines the horizontal field of view of the camera (in radians). Actually calls <a class="el" href="classqglviewer_1_1Camera.html#z5_4">setFieldOfView()</a> scaled by 1/<a class="el" href="classqglviewer_1_1Camera.html#z7_4">aspectRatio()</a>.
<p>
<a class="el" href="classqglviewer_1_1Camera.html#z15_1">loadProjectionMatrixStereo()</a> uses this value to define the camera offset and frustum.     </td>
  </tr>
</table>
<a name="z21_4" doxytag="qglviewer::Camera::setIODist"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setIODist </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>iod</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Defines the real inter-ocular distance (in meters). The default value used is 0.062m, which fits most people.
<p>
<a class="el" href="classqglviewer_1_1Camera.html#z15_1">loadProjectionMatrixStereo()</a> uses this value to define the camera offset and frustum     </td>
  </tr>
</table>
<a name="z11_2" doxytag="qglviewer::Camera::setKeyFrameInterpolator"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setKeyFrameInterpolator </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned short&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>i</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html">KeyFrameInterpolator</a> *const&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>kfi</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Changes the <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html">KeyFrameInterpolator</a> that currently defines the camera path of index <code>i</code>. The previous <a class="el" href="classqglviewer_1_1Camera.html#z11_1">keyFrameInterpolator()</a> is lost and the pointer should be deleted by the calling function if needed.
<p>
The <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html#j0">KeyFrameInterpolator::interpolated()</a> signal of <code>kfi</code> probably needs to be connected to the camera's associated viewer (if it exists), so that when the camera position is interpolated using <code>kfi</code>, every interpolation step updates the display.
<p>
<div class="fragment"><pre> <a class="code" href="classqglviewer_1_1Camera.html#z11_5">deleteKeyFramePath</a>(3);
 <a class="code" href="classqglviewer_1_1Camera.html#z11_2">setKeyFrameInterpolator</a>(3, myKeyFrameInterpolator);
 connect(myKeyFrameInterpolator, SIGNAL(interpolated()), myViewer, SLOT(updateGL());
</pre></div>
<p>
The <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html#j0">KeyFrameInterpolator::interpolated()</a> signal can also be connected to <em>all</em> the viewers updateGL() slots: <div class="fragment"><pre> <a class="code" href="classQGLViewer.html#z115_2">QGLViewer::connectSignalToAllViewers</a>(myKeyFrameInterpolator, SIGNAL(interpolated()));
</pre></div>
<p>
<dl compact><dt><b>Note: </b></dt><dd>
These connections are automatically performed when a <a class="el" href="classqglviewer_1_1Camera.html">Camera</a> is attached to a <a class="el" href="classQGLViewer.html">QGLViewer</a>, or when a new <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html">KeyFrameInterpolator</a> is defined using the key shortcuts (default is Alt F[1-12], see  the <a href="../shortcuts.html">QGLViewer shortcuts page</a> for details).</dl><dl compact><dt><b>Attention: </b></dt><dd>
Index <code>i</code> must be in the range 0..<a class="el" href="classqglviewer_1_1Camera.html#z11_0">nbPaths()</a>-1. </dl>    </td>
  </tr>
</table>
<a name="z1_8" doxytag="qglviewer::Camera::setOrientation"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setOrientation </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>theta</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>phi</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the orientation of the camera using polar coordinates <code>theta</code> and <code>phi</code> (in radians). <code>theta</code> rotates around the camera Y axis, and <em>then</em> <code>phi</code> rotates around the camera X axis. <code>theta</code> = <code>phi</code> = 0 means that the camera is directed towards the world Z axis. See also <a class="el" href="classqglviewer_1_1Camera.html#z3_8">setUpVector()</a>. The <a class="el" href="classqglviewer_1_1Camera.html#z1_0">position()</a> of the camera is unchanged, you may want to call <a class="el" href="classqglviewer_1_1Camera.html#z3_1">showEntireScene()</a> after this function to move the camera.
<p>
This function can be useful to create Quicktime VR panoramic sequences, see <a class="el" href="classQGLViewer.html#z99_3">QGLViewer::saveSnapshot()</a> for details.     </td>
  </tr>
</table>
<a name="z1_7" doxytag="qglviewer::Camera::setOrientation"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setOrientation </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>q0</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>q1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>q2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>q3</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as <a class="el" href="classqglviewer_1_1Camera.html#z1_6">setOrientation()</a>, but with float parameters.     </td>
  </tr>
</table>
<a name="z1_6" doxytag="qglviewer::Camera::setOrientation"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setOrientation </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classqglviewer_1_1Quaternion.html">Quaternion</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>q</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the camera orientation, defined with respect to the world coordinate system. The current camera orientation can be obtained from <a class="el" href="classqglviewer_1_1Camera.html#z1_1">orientation()</a>. The camera <a class="el" href="classqglviewer_1_1Camera.html#z1_0">position()</a> is not modified by this function. See also <a class="el" href="classqglviewer_1_1Camera.html#z3_5">lookAt()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z3_8">setUpVector()</a>.     </td>
  </tr>
</table>
<a name="z21_7" doxytag="qglviewer::Camera::setPhysicalScreenWidth"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setPhysicalScreenWidth </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>sw</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Defines the width of the real screen (in meters). Typically 0.4m (default value) for a monitor and 10m for the cylindrical wall in Reality Center.
<p>
<a class="el" href="classqglviewer_1_1Camera.html#z15_1">loadProjectionMatrixStereo()</a> uses this value to define the camera offset and frustum.     </td>
  </tr>
</table>
<a name="z1_5" doxytag="qglviewer::Camera::setPosition"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setPosition </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>z</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as <a class="el" href="classqglviewer_1_1Camera.html#z1_4">setPosition()</a>, but with float parameters.     </td>
  </tr>
</table>
<a name="z1_4" doxytag="qglviewer::Camera::setPosition"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setPosition </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>pos</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the camera position (the eye), defined in the world coordinate system. The current camera position can be obtained from <a class="el" href="classqglviewer_1_1Camera.html#z1_0">position()</a>.     </td>
  </tr>
</table>
<a name="z9_3" doxytag="qglviewer::Camera::setRevolveAroundPoint"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setRevolveAroundPoint </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>z</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
float version of <a class="el" href="classqglviewer_1_1Camera.html#z9_2">setRevolveAroundPoint()</a>.     </td>
  </tr>
</table>
<a name="z9_2" doxytag="qglviewer::Camera::setRevolveAroundPoint"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setRevolveAroundPoint </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>rap</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Changes the <a class="el" href="classqglviewer_1_1Camera.html#z9_0">revolveAroundPoint()</a>, which defines the position (in world coordinates) of the 3D point the camera revolves around in <a class="el" href="classQGLViewer.html#z111_0s1">QGLViewer::ROTATE</a> mode. Current value can be get from <a class="el" href="classqglviewer_1_1Camera.html#z9_0">revolveAroundPoint()</a>. Default value is <a class="el" href="classqglviewer_1_1Camera.html#z25_1">sceneCenter()</a>, which default value is (0,0,0).
<p>
The <a class="el" href="classqglviewer_1_1Camera.html#z7_0">zNear()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z7_1">zFar()</a> values are fitted to the scene, which will be entirely visible if <a class="el" href="classqglviewer_1_1Camera.html#z9_0">revolveAroundPoint()</a> is located inside a <a class="el" href="classqglviewer_1_1Camera.html#z25_0">sceneRadius()</a> sphere centered on <a class="el" href="classqglviewer_1_1Camera.html#z25_1">sceneCenter()</a>.
<p>
The camera position and orientation are not modified so that the image displayed by the camera is not affected by the <a class="el" href="classqglviewer_1_1Camera.html#z9_0">revolveAroundPoint()</a> change. <dl compact><dt><b>Attention: </b></dt><dd>
This value is modified by <a class="el" href="classqglviewer_1_1Camera.html#z25_4">setSceneCenter()</a>. </dl>    </td>
  </tr>
</table>
<a name="z9_4" doxytag="qglviewer::Camera::setRevolveAroundPointFromPixel"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool setRevolveAroundPointFromPixel </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>y</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The <a class="el" href="classqglviewer_1_1Camera.html#z9_0">revolveAroundPoint()</a> is set to the point located at pixel (x,y) on screen.
<p>
Returns <code>true</code> if a <a class="el" href="classqglviewer_1_1Camera.html#z7_13">pointUnderPixel()</a> was found. If no point was found under the pixel, the <a class="el" href="classqglviewer_1_1Camera.html#z9_0">revolveAroundPoint()</a> is unchanged.
<p>
This function is called when you press the right mouse button and then double click the left button. See <a href="../mouse.html">mouse page</a> for details.     </td>
  </tr>
</table>
<a name="z25_3" doxytag="qglviewer::Camera::setSceneBoundingBox"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setSceneBoundingBox </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>m</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>M</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Similar to <a class="el" href="classqglviewer_1_1Camera.html#z25_2">setSceneRadius()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z25_4">setSceneCenter()</a>, but the scene limits are defined by a bounding box.     </td>
  </tr>
</table>
<a name="z25_5" doxytag="qglviewer::Camera::setSceneCenter"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setSceneCenter </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>z</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as <a class="el" href="classqglviewer_1_1Camera.html#z25_4">setSceneCenter()</a>, but with <code>float</code> parameters.     </td>
  </tr>
</table>
<a name="z25_4" doxytag="qglviewer::Camera::setSceneCenter"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setSceneCenter </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>sc</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Changes the sceneCenter value (used for <a class="el" href="classqglviewer_1_1Camera.html#z7_0">zNear()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z7_1">zFar()</a>). This value is set from <a class="el" href="classQGLViewer.html#z89_6">QGLViewer::setSceneCenter()</a>. <dl compact><dt><b>Attention: </b></dt><dd>
<a class="el" href="classqglviewer_1_1Camera.html#z9_0">revolveAroundPoint()</a> is set to <a class="el" href="classqglviewer_1_1Camera.html#z25_1">sceneCenter()</a> by this method. </dl>    </td>
  </tr>
</table>
<a name="z25_6" doxytag="qglviewer::Camera::setSceneCenterFromPixel"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool setSceneCenterFromPixel </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>y</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classqglviewer_1_1Camera.html#z25_4">setSceneCenter()</a> to the result of <a class="el" href="classqglviewer_1_1Camera.html#z7_13">pointUnderPixel()</a> (if a point was found).
<p>
Returns <code>true</code> if a <a class="el" href="classqglviewer_1_1Camera.html#z7_13">pointUnderPixel()</a> was found and <a class="el" href="classqglviewer_1_1Camera.html#z25_1">sceneCenter()</a> was changed.     </td>
  </tr>
</table>
<a name="z25_2" doxytag="qglviewer::Camera::setSceneRadius"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setSceneRadius </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>r</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Scene radius (see <a class="el" href="classqglviewer_1_1Camera.html#z25_0">sceneRadius()</a>) scales axis and grid display and is used by <a class="el" href="classqglviewer_1_1Camera.html#z7_0">zNear()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z7_1">zFar()</a>. Should be set according to the displayed scene radius. This value is updated by the <a class="el" href="classQGLViewer.html#z89_5">QGLViewer::setSceneRadius()</a>.
<p>
<a class="el" href="classqglviewer_1_1Camera.html#z21_2">distanceToZeroParallaxPlane()</a> is set to <a class="el" href="classqglviewer_1_1Camera.html#z25_0">sceneRadius()</a>/tan(<a class="el" href="classqglviewer_1_1Camera.html#z5_0">fieldOfView()</a>/2) (used only for stereo mode, see <a class="el" href="classQGLViewer.html#z93_5">QGLViewer::setStereoDisplay()</a>, <a class="el" href="classqglviewer_1_1Camera.html#z5_4">setFieldOfView()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z21_6">setDistanceToZeroParallaxPlane()</a>).
<p>
See also <a class="el" href="classqglviewer_1_1Camera.html#z25_3">setSceneBoundingBox()</a>.     </td>
  </tr>
</table>
<a name="z5_7" doxytag="qglviewer::Camera::setType"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setType </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classqglviewer_1_1Camera.html#s2">Type</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>type</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Defines the camera type. Supported types are defined by the <a class="el" href="classqglviewer_1_1Camera.html#s2">Type()</a> enum. <a class="el" href="classqglviewer_1_1Camera.html#z15_0">loadProjectionMatrix()</a> will create the camera accordingly. Use <a class="el" href="classqglviewer_1_1Camera.html#z5_3">type()</a> to get the current value. <div class="fragment"><pre>myViewer.camera()-&gt;setType(<a class="code" href="classqglviewer_1_1Camera.html#s2s1">qglviewer::Camera::ORTHO</a>);
myViewer.camera()-&gt;showEntireScene();
</pre></div> In ORTHO mode, the <a class="el" href="classqglviewer_1_1Camera.html#z5_0">fieldOfView()</a> is meaningless and the width and height of the camera frustum are inferred from the distance to the <a class="el" href="classqglviewer_1_1Camera.html#z9_0">revolveAroundPoint()</a> (see <a class="el" href="classqglviewer_1_1Camera.html#z7_3">getOrthoWidthHeight()</a>).     </td>
  </tr>
</table>
<a name="z3_0" doxytag="qglviewer::Camera::setUpVector"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setUpVector </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>z</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>noMove</em> = true</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as <a class="el" href="classqglviewer_1_1Camera.html#z3_8">setUpVector()</a>, but with float parameters.     </td>
  </tr>
</table>
<a name="z3_8" doxytag="qglviewer::Camera::setUpVector"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setUpVector </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>up</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>noMove</em> = true</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Rotates the camera such that its up vector becomes <code>up</code> (defined in the world coordinate system). Only the orientation (not the position) of the camera is changed. The camera will be rotated around an axis orthogonal to <code>up</code> and to the current <a class="el" href="classqglviewer_1_1Camera.html#z7_9">upVector()</a> direction.
<p>
Use this function in order to define the horizontal plane in fly mode (<a class="el" href="classQGLViewer.html#z111_0s4">QGLViewer::MOVE_FORWARD</a> or <a class="el" href="classQGLViewer.html#z111_0s6">QGLViewer::MOVE_BACKWARD</a> binding).
<p>
However it might be interesting to compensate the orientation modification by a translation, so that the <a class="el" href="classqglviewer_1_1Camera.html#z9_0">revolveAroundPoint()</a> stays projected at the same position on screen. This is especially useful when the camera is an observer of the scene (default mouse binding) and it can be achieved when <code>noMove</code> is set to <code>false</code>. The default value for <code>noMove</code> is <code>true</code>, which results in an intuitive behavior when the camera is in a walkthrough fly mode (see <a class="el" href="classQGLViewer.html#z111_0s4">QGLViewer::MOVE_FORWARD</a>).     </td>
  </tr>
</table>
<a name="z27_2" doxytag="qglviewer::Camera::setWindowWidthAndHeight"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setWindowWidthAndHeight </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>w</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>h</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Update a copy of the <a class="el" href="classQGLViewer.html">QGLViewer</a> window dimensions. Called by the <a class="el" href="classQGLViewer.html">QGLViewer</a> when it is resized.
<p>
You should not call this function directly, as the <a class="el" href="classQGLViewer.html">QGLViewer</a> does it. However, if your <a class="el" href="classqglviewer_1_1Camera.html">Camera</a> is used <em>outside</em> of a <a class="el" href="classQGLViewer.html">QGLViewer</a> (offscreen rendering, shadow maps), you need to provide the screen width and height (see <a class="el" href="classqglviewer_1_1Camera.html#z7_5">screenWidth()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z7_6">screenHeight()</a>) in order to define the camera <a class="el" href="classqglviewer_1_1Camera.html#z7_4">aspectRatio()</a> which is used to define the projection matrix in <a class="el" href="classqglviewer_1_1Camera.html#z15_0">loadProjectionMatrix()</a>.     </td>
  </tr>
</table>
<a name="z7_16" doxytag="qglviewer::Camera::setZNearCoef"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setZNearCoef </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>coef</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This value is used when the camera is <em>inside</em> the <a class="el" href="classqglviewer_1_1Camera.html#z25_0">sceneRadius()</a>, <a class="el" href="classqglviewer_1_1Camera.html#z25_1">sceneCenter()</a> sphere. The <a class="el" href="classqglviewer_1_1Camera.html#z7_0">zNear()</a> value is then set to <a class="el" href="classqglviewer_1_1Camera.html#z7_2">zNearCoef()</a> * <a class="el" href="classqglviewer_1_1Camera.html#z25_0">sceneRadius()</a>. Default value is 0.001, which is appropriate for walkthrough applications. In case you need a high dynamic ZBuffer precision, you can increase this value (~0.1). A lower value will prevent clipping of very close objects at the expense of a worst Z precision.     </td>
  </tr>
</table>
<a name="z3_1" doxytag="qglviewer::Camera::showEntireScene"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void showEntireScene </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Adjust the camera so that the entire scene is visible. The camera is <em>translated</em> to make the entire scene fit the window, its <a class="el" href="classqglviewer_1_1Camera.html#z1_1">orientation()</a> is unchanged. The scene is defined by the QGLViewer::sceneCenter() and <a class="el" href="classQGLViewer.html#z89_0">QGLViewer::sceneRadius()</a>. The <a class="el" href="classqglviewer_1_1Camera.html#z5_0">fieldOfView()</a> is <em>not</em> modified by this function.
<p>
<a class="el" href="classQGLViewer.html#z89_9">QGLViewer::showEntireScene()</a> simply calls this function. See also <a class="el" href="classqglviewer_1_1Camera.html#z3_10">setFOVToFitScene()</a>.
<p>
You will typically use this function in <a class="el" href="classQGLViewer.html#b2">QGLViewer::init()</a>: <div class="fragment"><pre>  <a class="code" href="classqglviewer_1_1Camera.html#z25_2">setSceneRadius</a>(3.0);
  <a class="code" href="classqglviewer_1_1Camera.html#z3_1">showEntireScene</a>();
</pre></div>
<p>
You should orientate the camera <em>before</em> you call this function. See <a class="el" href="classqglviewer_1_1Camera.html#z3_5">lookAt()</a>, <a class="el" href="classqglviewer_1_1Camera.html#z1_6">setOrientation()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z3_8">setUpVector()</a>.
<p>
By default the <a class="el" href="classQGLViewer.html#z89_0">QGLViewer::sceneRadius()</a> is 1.0, and the <a class="el" href="classQGLViewer.html">QGLViewer</a> constructor calls this function. See also <a class="el" href="classqglviewer_1_1Camera.html#z3_7">centerScene()</a>.
<p>
<a class="el" href="classqglviewer_1_1MouseGrabber.html#z83_1">ManipulatedCameraFrame::mouseDoubleClickEvent()</a> calls this function after a middle button double click.     </td>
  </tr>
</table>
<a name="z5_3" doxytag="qglviewer::Camera::type"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classqglviewer_1_1Camera.html#s2">Type</a> type </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the type of the camera used by the <a class="el" href="classQGLViewer.html">QGLViewer</a>. Set by <a class="el" href="classqglviewer_1_1Camera.html#z5_7">setType()</a>. Supported types are defined by the <a class="el" href="classqglviewer_1_1Camera.html#s2">Type()</a> enum. Used by <a class="el" href="classqglviewer_1_1Camera.html#z15_0">loadProjectionMatrix()</a>.     </td>
  </tr>
</table>
<a name="z19_2" doxytag="qglviewer::Camera::unprojectedCoordinatesOf"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> unprojectedCoordinatesOf </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>src</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the world unprojected coordinates of a point <code>src</code> defined in the screen coordinate system. The <code>x</code> and <code>y</code> input values are expressed in pixel, (0,0) being the <em>upper</em> left corner. <code>z</code> is a depth value, between 0 and 1. See the <code>gluUnProject</code> man page for details.
<p>
This method is not computationally optimized. If you call it several times with no change in the matrices, you should buffer the entire inverse projection matrix (modelview, projection and then viewport) to speed-up the queries. See the <code>gluUnProject</code> man page for details.
<p>
<a class="el" href="classqglviewer_1_1Camera.html#z19_0">projectedCoordinatesOf()</a> performs the inverse transformation.
<p>
<dl compact><dt><b>Attention: </b></dt><dd>
If not used in <a class="el" href="classQGLViewer.html#b6">QGLViewer::draw()</a> or similar functions, call makeCurrent() and <a class="el" href="classqglviewer_1_1Camera.html#z15_8">computeModelViewMatrix()</a> before calling this function. </dl>    </td>
  </tr>
</table>
<a name="z7_9" doxytag="qglviewer::Camera::upVector"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> upVector </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the current up vector of the camera, defined in the world coordinate system. See also <a class="el" href="classqglviewer_1_1Camera.html#z3_8">setUpVector()</a>.
<p>
Simply returns : <div class="fragment"><pre>  <a class="code" href="classqglviewer_1_1Camera.html#z13_0">frame</a>()-&gt;inverseTransformOf(Vec(0.0,1.0,0.0));
</pre></div>     </td>
  </tr>
</table>
<a name="z7_11" doxytag="qglviewer::Camera::viewDirection"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> viewDirection </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the normalized view direction of the camera (negative Z axis), defined in the world coordinate system.     </td>
  </tr>
</table>
<a name="z17_3" doxytag="qglviewer::Camera::worldCoordinatesOf"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> worldCoordinatesOf </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classqglviewer_1_1Vec.html">Vec</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>src</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the world coordinates of the point whose position is <code>src</code>, defined in the camera coordinate system. <a class="el" href="classqglviewer_1_1Camera.html#z17_1">cameraCoordinatesOf()</a> performs the inverse transformation.     </td>
  </tr>
</table>
<a name="z7_1" doxytag="qglviewer::Camera::zFar"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> float zFar </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the zFar value used by the projection matrix. This value is fitted to <a class="el" href="classqglviewer_1_1Camera.html#z25_1">sceneCenter()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z25_0">sceneRadius()</a> in order to ensure an optimal z sampling: <div class="fragment"><pre>  <span class="keywordtype">float</span> coef = sqrt(2.0); <span class="comment">// so that a 1x1 grid fits</span>
  <span class="keywordflow">if</span> (<a class="code" href="classqglviewer_1_1Camera.html#z27_0">cameraPathIsEdited</a>())
    coef = 5.0;
  <a class="code" href="classqglviewer_1_1Camera.html#z7_1">zFar</a>=<a class="code" href="classqglviewer_1_1Camera.html#z7_8">distanceToSceneCenter</a>() + coef*<a class="code" href="classqglviewer_1_1Camera.html#z25_0">sceneRadius</a>();
</pre></div>
<p>
The <code>coef</code> of 5.0 in front of <code><a class="el" href="classqglviewer_1_1Camera.html#z25_0">sceneRadius()</a></code> is used to prevent a clipping of the camera paths when <a class="el" href="classQGLViewer.html#z87_5">QGLViewer::cameraPathIsEdited()</a>.
<p>
<dl compact><dt><b>Attention: </b></dt><dd>
The value is always positive and is the opposite of the camera frame actual value which is always negative. This is done in order to fit the <code>gluPerspective</code> positive standard. </dl>    </td>
  </tr>
</table>
<a name="z7_0" doxytag="qglviewer::Camera::zNear"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> float zNear </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the zNear value used by the projection matrix. This value is fitted to <a class="el" href="classqglviewer_1_1Camera.html#z25_1">sceneCenter()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z25_0">sceneRadius()</a> in order to ensure an optimal z sampling: <div class="fragment"><pre><span class="keywordtype">float</span> coef = sqrt(2.0); <span class="comment">// so that a 1x1 grid fits</span>
<span class="keywordflow">if</span> (<a class="code" href="classqglviewer_1_1Camera.html#z27_0">cameraPathIsEdited</a>())
  coef = 5.0;
<a class="code" href="classqglviewer_1_1Camera.html#z7_0">zNear</a> = <a class="code" href="classqglviewer_1_1Camera.html#z7_8">distanceToSceneCenter</a>() - coef*<a class="code" href="classqglviewer_1_1Camera.html#z25_0">sceneRadius</a>();

<span class="comment">// Prevents negative or null zNear values.</span>
<span class="keywordflow">if</span> (<a class="code" href="classqglviewer_1_1Camera.html#z7_0">zNear</a> &lt; <a class="code" href="classqglviewer_1_1Camera.html#z7_2">zNearCoef</a>() * <a class="code" href="classqglviewer_1_1Camera.html#z25_0">sceneRadius</a>())
   <span class="keywordflow">switch</span> (<a class="code" href="classqglviewer_1_1Camera.html#z5_3">type</a>())
   {
   <span class="keywordflow">case</span> Camera::PERSPECTIVE : <a class="code" href="classqglviewer_1_1Camera.html#z7_0">zNear</a> = <a class="code" href="classqglviewer_1_1Camera.html#z7_2">zNearCoef</a>() * <a class="code" href="classqglviewer_1_1Camera.html#z25_0">sceneRadius</a>(); <span class="keywordflow">break</span>;
   <span class="keywordflow">case</span> Camera::ORTHO       : <a class="code" href="classqglviewer_1_1Camera.html#z7_0">zNear</a> = 0.0; <span class="keywordflow">break</span>;
   }
</pre></div>
<p>
Returned value is clipped when the camera is inside the scene sphere to prevent negative or too small <a class="el" href="classqglviewer_1_1Camera.html#z7_0">zNear()</a> values (see <a class="el" href="classqglviewer_1_1Camera.html#z7_16">setZNearCoef()</a>).
<p>
The <code>coef</code> of 5.0 in front of <code><a class="el" href="classqglviewer_1_1Camera.html#z25_0">sceneRadius()</a></code> is used to prevent a clipping of the camera paths when <a class="el" href="classQGLViewer.html#z87_5">QGLViewer::cameraPathIsEdited()</a>.
<p>
<dl compact><dt><b>Attention: </b></dt><dd>
The value is always positive and is the opposite of the camera frame actual value (always negative). This is done in order to fit the <code>gluPerspective</code> positive standard. </dl>    </td>
  </tr>
</table>
<a name="z7_2" doxytag="qglviewer::Camera::zNearCoef"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> float zNearCoef </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the coefficient which is used to set <a class="el" href="classqglviewer_1_1Camera.html#z7_0">zNear()</a> when the camera is inside the <a class="el" href="classqglviewer_1_1Camera.html#z25_0">sceneRadius()</a> sphere. Set with <a class="el" href="classqglviewer_1_1Camera.html#z7_16">setZNearCoef()</a>. Only meaningful when camera type is <a class="el" href="classqglviewer_1_1Camera.html#s2s0">Camera::PERSPECTIVE</a>.     </td>
  </tr>
</table>
<hr><address style="align: right;"><small>Generated on Fri Apr 30 16:38:23 2004 for libQGLViewer by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>
