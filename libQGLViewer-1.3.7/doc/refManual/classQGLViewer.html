<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>QGLViewer class Reference</title>
<link href="qglviewer.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="functions.html">All&nbsp;functions</a> | <a class="qindex" doxygen="_cgi:http://www-imagis.imag.fr/cgi-bin/DOXYGEN/search.cgi" href="http://www-imagis.imag.fr/cgi-bin/DOXYGEN/search.cgi">Search</a> &nbsp; </center>
<hr><h1>QGLViewer Class Reference</h1>An OpenGL viewer based on QGLWidget. 
<a href="#_details">More...</a>
<p>
<a href="classQGLViewer-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Mouse behavior customization</h2></td></tr>
<tr><td nowrap align=right valign=top>enum &nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z111_0">MouseAction</a> { <br>
&nbsp;&nbsp;<a class="el" href="classQGLViewer.html#z111_0s0">NO_MOUSE_ACTION</a>, 
<a class="el" href="classQGLViewer.html#z111_0s1">ROTATE</a>, 
<a class="el" href="classQGLViewer.html#z111_0s2">ZOOM</a>, 
<a class="el" href="classQGLViewer.html#z111_0s3">TRANSLATE</a>, 
<a class="el" href="classQGLViewer.html#z111_0s4">MOVE_FORWARD</a>, 
<a class="el" href="classQGLViewer.html#z111_0s5">LOOK_AROUND</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classQGLViewer.html#z111_0s6">MOVE_BACKWARD</a>, 
<a class="el" href="classQGLViewer.html#z111_0s7">SCREEN_ROTATE</a>, 
<a class="el" href="classQGLViewer.html#z111_0s8">SCREEN_ROTATE_BOTTOM</a>, 
<a class="el" href="classQGLViewer.html#z111_0s9">SCREEN_TRANSLATE</a>, 
<a class="el" href="classQGLViewer.html#z111_0s10">ZOOM_ON_REGION</a>
<br>
 }</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z111_1">setMouseStateKey</a> (<a class="el" href="classQGLViewer.html#z111_13">MouseHandler</a> mh, int buttonState)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z111_2">setMouseBinding</a> (int buttonState, <a class="el" href="classQGLViewer.html#z111_13">MouseHandler</a> handler, <a class="el" href="classQGLViewer.html#z111_0">MouseAction</a> action, bool withConstraint=true)</td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classQGLViewer.html#z111_0">MouseAction</a>&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z111_3">mouseAction</a> (int buttonState)</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z111_4">mouseHandler</a> (int buttonState)</td></tr>
<tr><td nowrap align=right valign=top>Qt::ButtonState&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z111_5">mouseButtonState</a> (<a class="el" href="classQGLViewer.html#z111_13">MouseHandler</a> mh, <a class="el" href="classQGLViewer.html#z111_0">MouseAction</a> ma, bool withConstraint=true)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z111_6">setMouseBinding</a> (int buttonState, <a class="el" href="classQGLViewer.html#z111_14">ClickAction</a> action, bool doubleClick=false, int buttonBefore=Qt::NoButton)</td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classQGLViewer.html#z111_14">ClickAction</a>&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z111_7">clickAction</a> (int buttonState, bool doubleClick, int buttonBefore)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z111_8">getClickButtonState</a> (<a class="el" href="classQGLViewer.html#z111_14">ClickAction</a> ca, Qt::ButtonState &amp;buttonState, bool &amp;doubleClick, Qt::ButtonState &amp;buttonBefore)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z111_9">setWheelBinding</a> (int stateKey, <a class="el" href="classQGLViewer.html#z111_13">MouseHandler</a> handler, <a class="el" href="classQGLViewer.html#z111_0">MouseAction</a> action, bool withConstraint=true)</td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classQGLViewer.html#z111_0">MouseAction</a>&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z111_10">wheelAction</a> (int buttonState)</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z111_11">wheelHandler</a> (int buttonState)</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z111_12">wheelButtonState</a> (<a class="el" href="classQGLViewer.html#z111_13">MouseHandler</a> mh, <a class="el" href="classQGLViewer.html#z111_0">MouseAction</a> ma, bool withConstraint=true)</td></tr>
<tr><td nowrap align=right valign=top>enum &nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z111_13">MouseHandler</a> { <a class="el" href="classQGLViewer.html#z111_13t13">CAMERA</a>, 
<a class="el" href="classQGLViewer.html#z111_13t14">FRAME</a>
 }</td></tr>
<tr><td nowrap align=right valign=top>enum &nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z111_14">ClickAction</a> { <br>
&nbsp;&nbsp;<a class="el" href="classQGLViewer.html#z111_14t15">NO_CLICK_ACTION</a>, 
<a class="el" href="classQGLViewer.html#z111_14t16">ZOOM_ON_PIXEL</a>, 
<a class="el" href="classQGLViewer.html#z111_14t17">ZOOM_TO_FIT</a>, 
<a class="el" href="classQGLViewer.html#z111_14t18">SELECT</a>, 
<a class="el" href="classQGLViewer.html#z111_14t19">RAP_FROM_PIXEL</a>, 
<a class="el" href="classQGLViewer.html#z111_14t20">RAP_IS_CENTER</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classQGLViewer.html#z111_14t21">CENTER_FRAME</a>, 
<a class="el" href="classQGLViewer.html#z111_14t22">CENTER_SCENE</a>, 
<a class="el" href="classQGLViewer.html#z111_14t23">SHOW_ENTIRE_SCENE</a>, 
<a class="el" href="classQGLViewer.html#z111_14t24">ALIGN_FRAME</a>, 
<a class="el" href="classQGLViewer.html#z111_14t25">ALIGN_CAMERA</a>
<br>
 }</td></tr>
<tr><td colspan=2><br><h2>Viewer colors</h2></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a>&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z85_0">backgroundColor</a> () const</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z85_1">getBackgroundColor</a> (float &amp;r, float &amp;g, float &amp;b) const</td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a>&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z85_2">foregroundColor</a> () const</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z85_3">getForegroundColor</a> (float &amp;r, float &amp;g, float &amp;b) const</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z85_4">setBackgroundColor</a> (const <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> &amp;color)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z85_5">setBackgroundColor</a> (float r, float g, float b)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z85_6">setBackgroundColor</a> (const QColor &amp;c)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z85_7">setForegroundColor</a> (const <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> &amp;color)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z85_8">setForegroundColor</a> (float r, float g, float b)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z85_9">setForegroundColor</a> (const QColor &amp;c)</td></tr>
<tr><td colspan=2><br><h2>Display of visual hints</h2></td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z87_0">axisIsDrawn</a> () const</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z87_1">gridIsDrawn</a> () const</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z87_2">fpsIsDisplayed</a> () const</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z87_3">zBufferIsDisplayed</a> () const</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z87_4">textIsEnabled</a> () const</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z87_5">cameraPathIsEdited</a> () const</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z87_6">setDrawAxis</a> (bool f=true)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z87_7">toggleDrawAxis</a> ()</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z87_8">setDrawGrid</a> (bool f=true)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z87_9">toggleDrawGrid</a> ()</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z87_10">setDisplayFPS</a> (bool f=true)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z87_11">toggleDisplayFPS</a> ()</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z87_12">setDisplayZBuffer</a> (bool f=true)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z87_13">toggleDisplayZBuffer</a> ()</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z87_14">setEnableText</a> (bool f=true)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z87_15">toggleEnableText</a> ()</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z87_16">editCameraPath</a> (bool edit=true)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z87_17">toggleCameraPathEditor</a> ()</td></tr>
<tr><td colspan=2><br><h2>Scene related values</h2></td></tr>
<tr><td nowrap align=right valign=top>float&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z89_0">sceneRadius</a> () const</td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a>&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z89_1">QGLViewer::sceneCenter</a> () const</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z89_2">getSceneCenter</a> (float &amp;x, float &amp;y, float &amp;z) const</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z89_3">setSceneBoundingBox</a> (const float m[3], const float M[3])</td></tr>
<tr><td nowrap align=right valign=top>float&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z89_4">currentFPS</a> ()</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z89_5">setSceneRadius</a> (float r)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z89_6">setSceneCenter</a> (const <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> &amp;sc)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z89_7">setSceneCenter</a> (float x, float y, float z)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z89_8">setSceneBoundingBox</a> (const <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> &amp;m, const <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> &amp;M)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z89_9">showEntireScene</a> ()</td></tr>
<tr><td colspan=2><br><h2>Associated objects</h2></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classqglviewer_1_1Camera.html">qglviewer::Camera</a> *&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z91_0">camera</a> () const</td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classqglviewer_1_1ManipulatedFrame.html">qglviewer::ManipulatedFrame</a> *&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z91_1">manipulatedFrame</a> () const</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z91_2">setCamera</a> (<a class="el" href="classqglviewer_1_1Camera.html">qglviewer::Camera</a> *const c)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z91_3">setManipulatedFrame</a> (<a class="el" href="classqglviewer_1_1ManipulatedFrame.html">qglviewer::ManipulatedFrame</a> *fr)</td></tr>
<tr><td colspan=2><br><h2>State of the viewer</h2></td></tr>
<tr><td nowrap align=right valign=top>float&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z93_0">aspectRatio</a> () const</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z93_1">isFullScreen</a> () const</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z93_2">displaysInStereo</a> () const</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z93_3">setFullScreen</a> (bool fs=true)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z93_4">toggleFullScreen</a> ()</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z93_5">setStereoDisplay</a> (bool s=true)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z93_6">toggleStereoDisplay</a> ()</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z93_7">toggleCameraMode</a> ()</td></tr>
<tr><td colspan=2><br><h2>Display functions</h2></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z95_0">drawAxis</a> (float scale=1.0f)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z95_1">drawGrid</a> ()</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z95_2">startScreenCoordinatesSystem</a> (bool upward=false) const</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z95_3">stopScreenCoordinatesSystem</a> () const</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z95_4">drawText</a> (int x, int y, const QString &amp;text, const QFont &amp;fnt=QFont())</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z95_5">draw3DText</a> (const <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> &amp;pos, const <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> &amp;normal, const QString &amp;string, GLfloat height=0.1f)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z95_6">drawLight</a> (GLenum light, float scale=1.0f) const</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z95_7">displayFPS</a> ()</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z95_8">displayZBuffer</a> () const</td></tr>
<tr><td colspan=2><br><h2>Mouse grabber</h2></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classqglviewer_1_1MouseGrabber.html">qglviewer::MouseGrabber</a> *&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z97_0">mouseGrabber</a> () const</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z97_1">setMouseGrabber</a> (<a class="el" href="classqglviewer_1_1MouseGrabber.html">qglviewer::MouseGrabber</a> *mg)</td></tr>
<tr><td colspan=2><br><h2>Snapshots</h2></td></tr>
<tr><td nowrap align=right valign=top>const QString &amp;&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z99_0">snapshotFilename</a> () const</td></tr>
<tr><td nowrap align=right valign=top>const QString &amp;&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z99_1">snapshotFormat</a> () const</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z99_2">snapshotCounter</a> () const</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z99_3">saveSnapshot</a> (bool automatic=false, bool overwrite=false)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z99_4">setSnapshotFilename</a> (const QString &amp;n)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z99_5">setSnapshotFormat</a> (const QString &amp;f)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z99_6">setSnapshotCounter</a> (const int c)</td></tr>
<tr><td colspan=2><br><h2>Animation</h2></td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z101_0">animationIsStarted</a> () const</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z101_1">animationPeriod</a> () const</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z101_2">setAnimationPeriod</a> (int msecs)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z101_3">startAnimation</a> ()</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z101_4">stopAnimation</a> ()</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z101_5">toggleAnimationMode</a> ()</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z101_6">animate</a> ()</td></tr>
<tr><td colspan=2><br><h2>Help window</h2></td></tr>
<tr><td nowrap align=right valign=top>virtual QString&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z103_0">helpString</a> () const</td></tr>
<tr><td nowrap align=right valign=top>virtual QString&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z103_1">mouseBindingsString</a> () const</td></tr>
<tr><td nowrap align=right valign=top>virtual QString&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z103_2">shortcutBindingsString</a> () const</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z103_3">help</a> ()</td></tr>
<tr><td colspan=2><br><h2>Object selection</h2></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z107_0">select</a> (const QMouseEvent *e)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z107_1">select</a> (int x, int y)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z107_2">beginSelection</a> (int x, int y)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z107_3">drawWithNames</a> ()</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z107_4">endSelection</a> (int x, int y)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z107_5">postSelection</a> (int, int)</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z107_6">selectedName</a> ()</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z107_7">setSelectedName</a> (int id)</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z107_8">selectBufferSize</a> ()</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z107_9">setSelectBufferSize</a> (int size)</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z107_10">selectRegionSize</a> ()</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z107_11">setSelectRegionSize</a> (int size)</td></tr>
<tr><td nowrap align=right valign=top>GLuint *&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z107_12">selectBuffer</a> ()</td></tr>
<tr><td colspan=2><br><h2>Key customization</h2></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z109_0">setShortcutKey</a> (<a class="el" href="classQGLViewer.html#z109_10">ShortcutAction</a> action, int key, int stateKey=-1)</td></tr>
<tr><td nowrap align=right valign=top>Qt::Key&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z109_1">shortcutKey</a> (<a class="el" href="classQGLViewer.html#z109_10">ShortcutAction</a> action) const</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z109_2">setShortcutStateKey</a> (<a class="el" href="classQGLViewer.html#z109_10">ShortcutAction</a> action, int buttonState)</td></tr>
<tr><td nowrap align=right valign=top>Qt::ButtonState&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z109_3">shortcutStateKey</a> (<a class="el" href="classQGLViewer.html#z109_10">ShortcutAction</a> action) const</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z109_4">setKeyFrameKey</a> (int nb, int key)</td></tr>
<tr><td nowrap align=right valign=top>Qt::Key&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z109_5">keyFrameKey</a> (int nb) const</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z109_6">setAddKeyFrameStateKey</a> (int buttonState)</td></tr>
<tr><td nowrap align=right valign=top>Qt::ButtonState&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z109_7">addKeyFrameStateKey</a> () const</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z109_8">setPlayKeyFramePathStateKey</a> (int buttonState)</td></tr>
<tr><td nowrap align=right valign=top>Qt::ButtonState&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z109_9">playKeyFramePathStateKey</a> () const</td></tr>
<tr><td nowrap align=right valign=top>enum &nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z109_10">ShortcutAction</a> { <br>
&nbsp;&nbsp;<a class="el" href="classQGLViewer.html#z109_10t0">DRAW_AXIS</a>, 
<a class="el" href="classQGLViewer.html#z109_10t1">DRAW_GRID</a>, 
<a class="el" href="classQGLViewer.html#z109_10t2">DISPLAY_FPS</a>, 
<a class="el" href="classQGLViewer.html#z109_10t3">DISPLAY_Z_BUFFER</a>, 
<a class="el" href="classQGLViewer.html#z109_10t4">ENABLE_TEXT</a>, 
<a class="el" href="classQGLViewer.html#z109_10t5">EXIT</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classQGLViewer.html#z109_10t6">SAVE_SCREENSHOT</a>, 
<a class="el" href="classQGLViewer.html#z109_10t7">CAMERA_MODE</a>, 
<a class="el" href="classQGLViewer.html#z109_10t8">FULL_SCREEN</a>, 
<a class="el" href="classQGLViewer.html#z109_10t9">STEREO</a>, 
<a class="el" href="classQGLViewer.html#z109_10t10">ANIMATION</a>, 
<a class="el" href="classQGLViewer.html#z109_10t11">HELP</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classQGLViewer.html#z109_10t12">EDIT_CAMERA_PATHS</a>
<br>
 }</td></tr>
<tr><td colspan=2><br><h2>Save and restore viewer state</h2></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z113_0">saveToFile</a> (const QString &amp;fileName="")</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z113_1">restoreFromFile</a> (const QString &amp;fileName="")</td></tr>
<tr><td nowrap align=right valign=top>virtual QDomElement&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z113_2">domElement</a> (const QString &amp;name, QDomDocument &amp;doc) const</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z113_3">initFromDOMElement</a> (const QDomElement &amp;de)</td></tr>
<tr><td colspan=2><br><h2>Visual hints</h2></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z117_0">setVisualHintsMask</a> (int mask, int delay=2000)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z117_1">drawVisualHints</a> ()</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z117_2">resetVisualHints</a> ()</td></tr>
<tr><td colspan=2><br><h2>Static methods for all the viewers</h2></td></tr>
<tr><td colspan=2>All the created QGLViewers are stored in a QGLViewerPool(). These methods allow you to use this pool.<br><br></td></tr>
<tr><td nowrap align=right valign=top>const QPtrList&lt; QGLViewer &gt; &amp;&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z115_0">QGLViewerPool</a> ()</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z115_1">QGLViewerIndex</a> (const QGLViewer *const v)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z115_2">connectSignalToAllViewers</a> (const QObject *sender, const char *signal, const char *member=SLOT(updateGL()))</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z115_3">disconnectSignalToAllViewers</a> (const QObject *sender, const char *signal, const char *member=SLOT(updateGL()))</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z115_4">updateGLForAllViewers</a> ()</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z115_5">saveToFileForAllViewers</a> ()</td></tr>
<tr><td colspan=2><br><h2>Mouse and keyboard handlers</h2></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z105_0">mousePressEvent</a> (QMouseEvent *)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z105_1">mouseDoubleClickEvent</a> (QMouseEvent *)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z105_2">mouseReleaseEvent</a> (QMouseEvent *)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z105_3">mouseMoveEvent</a> (QMouseEvent *)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z105_4">wheelEvent</a> (QWheelEvent *)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z105_5">timerEvent</a> (QTimerEvent *)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z105_6">closeEvent</a> (QCloseEvent *)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#z105_7">keyPressEvent</a> (QKeyEvent *)</td></tr>
<tr><td colspan=2><br><h2>Public Types</h2></td></tr>
<tr><td colspan=2><br><h2>Signals</h2></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#j0">viewerInitialized</a> ()</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#j1">drawNeeded</a> ()</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#j2">animateNeeded</a> ()</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#j3">helpRequired</a> ()</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#j4">axisDrawn</a> (bool on)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#j5">gridDrawn</a> (bool on)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#j6">fpsDisplayed</a> (bool on)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#j7">zBufferDisplayed</a> (bool on)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#j8">textEnabled</a> (bool on)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#j9">cameraPathEdited</a> (bool on)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#j10">stereoChanged</a> (bool on)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#j11">pointSelected</a> (const QMouseEvent *e)</td></tr>
<tr><td colspan=2><br><h2>Public Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#a0">QGLViewer</a> (QWidget *parent=NULL, const char *name=0, const QGLWidget *shareWidget=0, WFlags flags=0)</td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#a1">QGLViewer</a> (const QGLFormat &amp;format, QWidget *parent=0, const char *name=0, const QGLWidget *shareWidget=0, WFlags flags=0)</td></tr>
<tr><td nowrap align=right valign=top>virtual&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#a2">~QGLViewer</a> ()</td></tr>
<tr><td colspan=2><br><h2>Protected Types</h2></td></tr>
<tr><td colspan=2><br><h2>Protected Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#b0">resizeGL</a> (int w, int h)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#b1">initializeGL</a> ()</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#b2">init</a> ()</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#b3">paintGL</a> ()</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#b4">preDraw</a> ()</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#b5">preDrawStereo</a> (bool leftBuffer=true)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#b6">draw</a> ()</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#b7">fastDraw</a> ()</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#b8">postDraw</a> ()</td></tr>
<tr><td nowrap align=right valign=top>QWidget *&nbsp;</td><td valign=bottom><a class="el" href="classQGLViewer.html#b9">rootWidget</a> () const</td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
An OpenGL viewer based on QGLWidget.
<p>
A QGLViewer is a 3D OpenGL viewer based on the Qt's QGLWidget. It includes many classical viewer functionalities, such as a camera trackball, manipulated objects, snapshot saving and much <a href="../features.html">more</a>. Its main goal is to enable the very fast development of new 3D applications.
<p>
In order to display a scene, you simply have to derive the <a class="el" href="classQGLViewer.html#b6">draw()</a> function (or use the <a class="el" href="classQGLViewer.html#j1">drawNeeded()</a> signal, see below) and to provide the openGL orders that define your scene. New users should read the <a href="../intro.html">introduction page</a> to get familiar with important notions such as <a class="el" href="classQGLViewer.html#z89_0">sceneRadius()</a> and sceneCenter().
<p>
Try the numerous simple <a href="../examples/index.html">examples</a> to discover the possibilities and understand how it works. See also the Qt's QGLWidget documentation for details about inherited methods such as QGLWidget::setAutoBufferSwap() or QGLWidget::swapBuffers().
<p>
<h3>Instantiation</h3>

<p>
To use it, you can derive a class from it and overload the <a class="el" href="classQGLViewer.html#b6">draw()</a> virtual method. See the <a href="../examples/simpleViewer.html">simpleViewer</a> example for an introduction. <div class="fragment"><pre> <span class="comment">// The Viewer class inherits from QGLViewer and overloads the draw function.</span>
 <span class="keyword">class </span>Viewer : <span class="keyword">public</span> <a class="code" href="classQGLViewer.html">QGLViewer</a>
 {
   <span class="keyword">protected</span>:
   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classQGLViewer.html#b6">draw</a>();
   {
     <span class="comment">// Your OpenGL drawing code goes here...</span>
   }
 };
</pre></div>  A complete <a href="../commented.html">commented example</a> is also available.
<p>
An other method is to connect your drawing methods to the signals emitted by the QGLViewer (clean callback mechanism). See the <a href="../examples/callback.html">callback</a> example for a complete example. <div class="fragment"><pre> <span class="comment">// A Scene class holds the scene data and provides a drawScene function.</span>
 <span class="keyword">class </span>Scene : <span class="keyword">public</span> QObject
 {
   Q_OBJECT <span class="comment">// Needed in order to use the Qt signals/slots mechanism</span>
  
   <span class="keyword">public</span>:
     Scene(<span class="keyword">const</span> <a class="code" href="classQGLViewer.html">QGLViewer</a>* <span class="keyword">const</span> v);
  
   <span class="keyword">public</span> slots:
     <span class="keywordtype">void</span> drawScene();
 };

 Scene::Scene(<span class="keyword">const</span> <a class="code" href="classQGLViewer.html">QGLViewer</a>* <span class="keyword">const</span> viewer)
 {
   <span class="comment">// Connect the viewer signal to our draw function slot</span>
   connect(viewer, SIGNAL(drawNeeded()), SLOT(drawScene()));
 }
</pre></div> 
<p>
<hr><h2>Member Enumeration Documentation</h2>
<a name="z111_14" doxytag="QGLViewer::ClickAction"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum ClickAction<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Defines the possible actions that can be binded to a mouse click. ClickAction are binded using <a class="el" href="classQGLViewer.html#z111_2">setMouseBinding()</a>. See the <a href="../mouse.html">mouse page</a> for details. <dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a name="z111_14t15" doxytag="NO_CLICK_ACTION"></a><em>NO_CLICK_ACTION</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="z111_14t16" doxytag="ZOOM_ON_PIXEL"></a><em>ZOOM_ON_PIXEL</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="z111_14t17" doxytag="ZOOM_TO_FIT"></a><em>ZOOM_TO_FIT</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="z111_14t18" doxytag="SELECT"></a><em>SELECT</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="z111_14t19" doxytag="RAP_FROM_PIXEL"></a><em>RAP_FROM_PIXEL</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="z111_14t20" doxytag="RAP_IS_CENTER"></a><em>RAP_IS_CENTER</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="z111_14t21" doxytag="CENTER_FRAME"></a><em>CENTER_FRAME</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="z111_14t22" doxytag="CENTER_SCENE"></a><em>CENTER_SCENE</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="z111_14t23" doxytag="SHOW_ENTIRE_SCENE"></a><em>SHOW_ENTIRE_SCENE</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="z111_14t24" doxytag="ALIGN_FRAME"></a><em>ALIGN_FRAME</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="z111_14t25" doxytag="ALIGN_CAMERA"></a><em>ALIGN_CAMERA</em></em>&nbsp;</td><td>
</td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a name="z111_0" doxytag="QGLViewer::MouseAction"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum MouseAction
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Defines the possible actions that can be binded to a mouse motion (a click, followed by a mouse displacement). These actions may be applied to the <a class="el" href="classQGLViewer.html#z91_0">camera()</a> or to the <a class="el" href="classQGLViewer.html#z91_1">manipulatedFrame()</a> (see MouseHandler). Use <a class="el" href="classQGLViewer.html#z111_2">setMouseBinding()</a> to bind a mouse button to an action. See the <a href="../mouse.html">mouse page</a> for details. <dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a name="z111_0s0" doxytag="NO_MOUSE_ACTION"></a><em>NO_MOUSE_ACTION</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="z111_0s1" doxytag="ROTATE"></a><em>ROTATE</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="z111_0s2" doxytag="ZOOM"></a><em>ZOOM</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="z111_0s3" doxytag="TRANSLATE"></a><em>TRANSLATE</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="z111_0s4" doxytag="MOVE_FORWARD"></a><em>MOVE_FORWARD</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="z111_0s5" doxytag="LOOK_AROUND"></a><em>LOOK_AROUND</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="z111_0s6" doxytag="MOVE_BACKWARD"></a><em>MOVE_BACKWARD</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="z111_0s7" doxytag="SCREEN_ROTATE"></a><em>SCREEN_ROTATE</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="z111_0s8" doxytag="SCREEN_ROTATE_BOTTOM"></a><em>SCREEN_ROTATE_BOTTOM</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="z111_0s9" doxytag="SCREEN_TRANSLATE"></a><em>SCREEN_TRANSLATE</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="z111_0s10" doxytag="ZOOM_ON_REGION"></a><em>ZOOM_ON_REGION</em></em>&nbsp;</td><td>
</td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a name="z111_13" doxytag="QGLViewer::MouseHandler"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum MouseHandler<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Defines the different mouse handlers : Camera or Frame motion. Used by <a class="el" href="classQGLViewer.html#z111_2">setMouseBinding()</a> to define which handler receives the mouse displacements. See the <a href="../mouse.html">mouse page</a> for details. <dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a name="z111_13t13" doxytag="CAMERA"></a><em>CAMERA</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="z111_13t14" doxytag="FRAME"></a><em>FRAME</em></em>&nbsp;</td><td>
</td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a name="z109_10" doxytag="QGLViewer::ShortcutAction"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum ShortcutAction<code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Defines the different actions that can directly be associated with a keyboard shortcut. Used by <a class="el" href="classQGLViewer.html#z109_0">setShortcutKey()</a>, <a class="el" href="classQGLViewer.html#z109_2">setShortcutStateKey()</a>, <a class="el" href="classQGLViewer.html#z109_1">shortcutKey()</a> and <a class="el" href="classQGLViewer.html#z109_3">shortcutStateKey()</a>.
<p>
See the <a href="../shortcuts.html">QGLViewer shortcuts page</a> for details. <dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a name="z109_10t0" doxytag="DRAW_AXIS"></a><em>DRAW_AXIS</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="z109_10t1" doxytag="DRAW_GRID"></a><em>DRAW_GRID</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="z109_10t2" doxytag="DISPLAY_FPS"></a><em>DISPLAY_FPS</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="z109_10t3" doxytag="DISPLAY_Z_BUFFER"></a><em>DISPLAY_Z_BUFFER</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="z109_10t4" doxytag="ENABLE_TEXT"></a><em>ENABLE_TEXT</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="z109_10t5" doxytag="EXIT"></a><em>EXIT</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="z109_10t6" doxytag="SAVE_SCREENSHOT"></a><em>SAVE_SCREENSHOT</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="z109_10t7" doxytag="CAMERA_MODE"></a><em>CAMERA_MODE</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="z109_10t8" doxytag="FULL_SCREEN"></a><em>FULL_SCREEN</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="z109_10t9" doxytag="STEREO"></a><em>STEREO</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="z109_10t10" doxytag="ANIMATION"></a><em>ANIMATION</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="z109_10t11" doxytag="HELP"></a><em>HELP</em></em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a name="z109_10t12" doxytag="EDIT_CAMERA_PATHS"></a><em>EDIT_CAMERA_PATHS</em></em>&nbsp;</td><td>
</td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a name="a0" doxytag="QGLViewer::QGLViewer"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> QGLViewer </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">QWidget *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>parent</em> = NULL, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>name</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const QGLWidget *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>shareWidget</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>WFlags&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>flags</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set default display flags, initializes camera and other parameters. Calls the QGLWidget constructor with the same parameters. Calls <a class="el" href="classqglviewer_1_1Camera.html#z21_5">qglviewer::Camera::setDistanceToScreen</a>(4.0) and <a class="el" href="classqglviewer_1_1Camera.html#z21_7">qglviewer::Camera::setPhysicalScreenWidth</a>(10.0) when screen aspect ratio &gt; 2 (Reality Center).
<p>
See the Qt::QGLWidget associated constructor documentation for details on the parameters.     </td>
  </tr>
</table>
<a name="a1" doxytag="QGLViewer::QGLViewer"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> QGLViewer </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const QGLFormat &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>format</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>QWidget *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>parent</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>name</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const QGLWidget *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>shareWidget</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>WFlags&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>flags</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as <a class="el" href="classQGLViewer.html#a0">QGLViewer()</a>, but a Qt::QGLFormat can be provided (used for stereo display in the <a href="../examples/stereoViewer.html">stereoViewer</a> example.     </td>
  </tr>
</table>
<a name="a2" doxytag="QGLViewer::~QGLViewer"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ~QGLViewer </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Virtual destructor. Removes object from <a class="el" href="classQGLViewer.html#z115_0">QGLViewerPool()</a> and releases allocated memory.     </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a name="z109_7" doxytag="QGLViewer::addKeyFrameStateKey"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> Qt::ButtonState addKeyFrameStateKey </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the state key (Qt::AltButton, Qt::ShiftButton, Qt::ControlButton) that must be pressed with the <a class="el" href="classQGLViewer.html#z109_5">keyFrameKey()</a> to <em>add</em> a KeyFrame to a camera KeyFrame path. Default value is Qt::AltButton. See <a class="el" href="classQGLViewer.html#z109_6">setAddKeyFrameStateKey()</a> for details.
<p>
See also <a class="el" href="classQGLViewer.html#z109_5">keyFrameKey()</a> and <a class="el" href="classQGLViewer.html#z109_9">playKeyFramePathStateKey()</a>.
<p>
See the <a href="../shortcuts.html">QGLViewer shortcuts page</a> for details.     </td>
  </tr>
</table>
<a name="z101_6" doxytag="QGLViewer::animate"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void animate </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, virtual, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Scene animation function. Once <a class="el" href="classQGLViewer.html#z101_3">startAnimation()</a> has been called, an infinite loop calls <a class="el" href="classQGLViewer.html#z101_6">animate()</a> and <a class="el" href="classQGLViewer.html#b6">draw()</a>.
<p>
See the <a href="../examples/animation.html">animation</a> example for an illustration.     </td>
  </tr>
</table>
<a name="j2" doxytag="QGLViewer::animateNeeded"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void animateNeeded </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [signal]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Signal emitted by the default <a class="el" href="classQGLViewer.html#z101_6">QGLViewer::animate()</a> function. Connect this signal to your scene animation function.
<p>
Use this signal-slot mechanism ONLY IF you don't inherit your viewer from QGLViewer (in that case, simply overload the <a class="el" href="classQGLViewer.html#z101_6">animate()</a> function).     </td>
  </tr>
</table>
<a name="z101_0" doxytag="QGLViewer::animationIsStarted"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool animationIsStarted </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return true when the animation loop is started, i.e. viewer calls <a class="el" href="classQGLViewer.html#z101_6">animate()</a> and <a class="el" href="classQGLViewer.html#b6">draw()</a>. See <a class="el" href="classQGLViewer.html#z101_3">startAnimation()</a> and <a class="el" href="classQGLViewer.html#z101_6">animate()</a>. You should override this method if your scene contains animated elements (KeyFrameInterpolator driven objects excepted).     </td>
  </tr>
</table>
<a name="z101_1" doxytag="QGLViewer::animationPeriod"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int animationPeriod </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The animation loop period, in milliseconds. See <a class="el" href="classQGLViewer.html#z101_3">startAnimation()</a> and <a class="el" href="classQGLViewer.html#z101_6">animate()</a>.     </td>
  </tr>
</table>
<a name="z93_0" doxytag="QGLViewer::aspectRatio"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> float aspectRatio </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the aspect ratio of the GL widget. That is the ratio between its width and height (see the Qt QGLWidget documentation).     </td>
  </tr>
</table>
<a name="j4" doxytag="QGLViewer::axisDrawn"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void axisDrawn </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>on</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [signal]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This signal is emitted whenever <a class="el" href="classQGLViewer.html#z87_0">axisIsDrawn()</a> changes value. This can be done with <a class="el" href="classQGLViewer.html#z87_6">setDrawAxis()</a> or <a class="el" href="classQGLViewer.html#z87_7">toggleDrawAxis()</a>.     </td>
  </tr>
</table>
<a name="z87_0" doxytag="QGLViewer::axisIsDrawn"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool axisIsDrawn </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns <code>true</code> if the world axis is drawn by the viewer. Set by <a class="el" href="classQGLViewer.html#z87_6">setDrawAxis()</a> or <a class="el" href="classQGLViewer.html#z87_7">toggleDrawAxis()</a>.     </td>
  </tr>
</table>
<a name="z85_0" doxytag="QGLViewer::backgroundColor"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> backgroundColor </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<code>Returns</code> the current background color of the viewer. The <code>x</code>, <code>y</code> and <code>z</code> of the result represent the red, green and blue color components. Use <a class="el" href="classQGLViewer.html#z85_4">setBackgroundColor()</a> to define the background color.
<p>
This function is provided for convenience as the background color is an OpenGL state variable set with <code>glClearColor()</code> (see <a class="el" href="classQGLViewer.html#z85_4">setBackgroundColor()</a>). However, this internal representation has the advantage that it is saved (resp. restored) with <a class="el" href="classQGLViewer.html#z113_0">saveToFile()</a> (resp. <a class="el" href="classQGLViewer.html#z113_1">restoreFromFile()</a>) as it is part of the <a class="el" href="classQGLViewer.html#z113_2">domElement()</a>.
<p>
Default value is (0.2, 0.2, 0.2) (dark gray). Each color component ranges between 0.0 and 1.0 (see the <code>glColor3f()</code> documentation). You may have to change <a class="el" href="classQGLViewer.html#z85_2">foregroundColor()</a> accordingly (see <a class="el" href="classQGLViewer.html#z85_7">setForegroundColor()</a>). See also the QGLWidget::qglColor() and QGLWidget::qglClearColor() documentations.
<p>
<dl compact><dt><b>Attention: </b></dt><dd>
If you directly use <code>glClearColor()</code> instead of <a class="el" href="classQGLViewer.html#z85_4">setBackgroundColor()</a>, the result of this function will be erroneous. Consider using a <code>glGet()</code> to retrieve the actual current value in that case. </dl>    </td>
  </tr>
</table>
<a name="z107_2" doxytag="QGLViewer::beginSelection"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void beginSelection </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>y</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method should prepare the selection. It is called by <a class="el" href="classQGLViewer.html#z107_0">select()</a> before <a class="el" href="classQGLViewer.html#z107_3">drawWithNames()</a>.
<p>
The default implementation uses the <code>GL_SELECT</code> mode to perform a selection. It uses <a class="el" href="classQGLViewer.html#z107_12">selectBuffer()</a> and <a class="el" href="classQGLViewer.html#z107_8">selectBufferSize()</a> to define a <code>glSelectBuffer()</code>. The <code>GL_PROJECTION</code> is then set using gluPickMatrix(), with a window selection size defined by <a class="el" href="classQGLViewer.html#z107_10">selectRegionSize()</a>. Finally, the <code>GL_MODELVIEW</code> matrix is set to the world coordinate sytem using <a class="el" href="classqglviewer_1_1Camera.html#z15_2">qglviewer::Camera::loadModelViewMatrix()</a>.
<p>
You should have to redefine this function (if you use the <code>GL_SELECT</code> mode to perform your selection), since this code is fairly classical and can be tuned using <a class="el" href="classQGLViewer.html#z107_9">setSelectBufferSize()</a> and <a class="el" href="classQGLViewer.html#z107_11">setSelectRegionSize()</a>. You are more likely to overload <a class="el" href="classQGLViewer.html#z107_4">endSelection()</a> if you want to use a more complex select buffer structure.     </td>
  </tr>
</table>
<a name="z91_0" doxytag="QGLViewer::camera"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classqglviewer_1_1Camera.html">qglviewer::Camera</a>* camera </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The camera that is used by the viewer. See the <a class="el" href="classqglviewer_1_1Camera.html">qglviewer::Camera</a> documentation for a complete description of the available functions.     </td>
  </tr>
</table>
<a name="j9" doxytag="QGLViewer::cameraPathEdited"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void cameraPathEdited </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>on</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [signal]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This signal is emitted whenever <a class="el" href="classQGLViewer.html#z87_5">cameraPathIsEdited()</a> changes value. This can be done with <a class="el" href="classQGLViewer.html#z87_16">editCameraPath()</a> or <a class="el" href="classQGLViewer.html#z87_17">toggleCameraPathEditor()</a>.     </td>
  </tr>
</table>
<a name="z87_5" doxytag="QGLViewer::cameraPathIsEdited"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool cameraPathIsEdited </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns <code>true</code> if the camera paths are being edited in the viewer. Set by <a class="el" href="classQGLViewer.html#z87_16">editCameraPath()</a> or <a class="el" href="classQGLViewer.html#z87_17">toggleCameraPathEditor()</a> (default <code>EDIT_CAMERA_PATHS</code> shortcut key is 'C'). Default value is <code>false</code>.
<p>
When <a class="el" href="classQGLViewer.html#z87_5">cameraPathIsEdited()</a>, the camera paths that are defined are displayed using <a class="el" href="classqglviewer_1_1Camera.html#z11_7">qglviewer::Camera::drawAllPaths()</a>. <a class="el" href="classqglviewer_1_1Camera.html#z7_0">qglviewer::Camera::zNear()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z7_1">qglviewer::Camera::zFar()</a> are modified so that the paths are not clipped. zBuffer precision is highly affected.     </td>
  </tr>
</table>
<a name="z111_7" doxytag="QGLViewer::clickAction"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classQGLViewer.html#z111_14">QGLViewer::ClickAction</a> clickAction </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>buttonState</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>doubleClick</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>buttonBefore</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as <a class="el" href="classQGLViewer.html#z111_3">mouseAction()</a>, but for the click action set using <a class="el" href="classQGLViewer.html#z111_2">setMouseBinding()</a>.     </td>
  </tr>
</table>
<a name="z105_6" doxytag="QGLViewer::closeEvent"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void closeEvent </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">QCloseEvent *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>e</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Save the viewer current state using <a class="el" href="classQGLViewer.html#z113_0">saveToFile()</a> and then call QGLWidget::closeEvent().     </td>
  </tr>
</table>
<a name="z115_2" doxytag="QGLViewer::connectSignalToAllViewers"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void connectSignalToAllViewers </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const QObject *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>sender</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>signal</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>member</em> = SLOT(updateGL())</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Connect a signal to a signal or a slot of <em>all</em> the QGLViewers.
<p>
Typical usage would be: <div class="fragment"><pre><a class="code" href="classQGLViewer.html#z115_2">connectSignalToAllViewers</a>(myScene, SIGNAL(needsRedisplay()));
</pre></div>
<p>
The default target signal is updateGL(), but any other signal/slot can be used. This function will silently ignore the connections that cannot be established.
<p>
See also <a class="el" href="classQGLViewer.html#z115_0">QGLViewerPool()</a>, <a class="el" href="classQGLViewer.html#z115_3">disconnectSignalToAllViewers()</a> and <a class="el" href="classQGLViewer.html#z115_4">updateGLForAllViewers()</a>.     </td>
  </tr>
</table>
<a name="z89_4" doxytag="QGLViewer::currentFPS"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> float currentFPS </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the current viewer frame rate, as displayed by <a class="el" href="classQGLViewer.html#z95_7">displayFPS()</a> (see <a class="el" href="classQGLViewer.html#z87_10">setDisplayFPS()</a> and <a class="el" href="classQGLViewer.html#z87_11">toggleDisplayFPS()</a>).
<p>
This function is useful for true real-time applications that may adapt the computational load according to frame rate evolution in order to maintain a given frequency.
<p>
Note that for stability reasons this value is averaged over 25 frames, and hence will only change every 25 draw. As Qt redraws the window only when needed, this value is meaningful only when <a class="el" href="classQGLViewer.html#z101_3">startAnimation()</a> is called, when you use <a class="el" href="classqglviewer_1_1Camera.html#z11_4">qglviewer::Camera::playKeyFramePath()</a> or when the camera is manipulated with the mouse, so that <a class="el" href="classQGLViewer.html#b6">draw()</a> is called in a loop.     </td>
  </tr>
</table>
<a name="z115_3" doxytag="QGLViewer::disconnectSignalToAllViewers"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void disconnectSignalToAllViewers </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const QObject *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>sender</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>signal</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>member</em> = SLOT(updateGL())</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Disconnect a signal to a signal or a slot of <em>all</em> the QGLViewers. Used in conjunction with <a class="el" href="classQGLViewer.html#z115_2">connectSignalToAllViewers()</a>.
<p>
The default target signal is updateGL(), but any other signal/slot can be used. This function will silently ignore the connections that cannot be removed. See also <a class="el" href="classQGLViewer.html#z115_4">updateGLForAllViewers()</a>.     </td>
  </tr>
</table>
<a name="z95_7" doxytag="QGLViewer::displayFPS"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void displayFPS </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Display the frame rate in the corner of the window. The frame rate is computed as an average and updateGL() must be called in a loop in order to have a meaningful value (this is the case when <a class="el" href="classQGLViewer.html#z101_0">animationIsStarted()</a>). The FPS display can be toggled with <a class="el" href="classQGLViewer.html#z87_11">toggleDisplayFPS()</a> (Default shortcut key is 'F', see DISPLAY_FPS) or with <a class="el" href="classQGLViewer.html#z87_10">setDisplayFPS()</a>. Use QApplication::setFont() to define the FPS font (see <a class="el" href="classQGLViewer.html#z95_4">drawText()</a>). Get current application (averaged) frame rate with <a class="el" href="classQGLViewer.html#z89_4">currentFPS()</a>.     </td>
  </tr>
</table>
<a name="z93_2" doxytag="QGLViewer::displaysInStereo"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool displaysInStereo </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns <code>true</code> if the viewer displays in stereo. Set by <a class="el" href="classQGLViewer.html#z93_5">setStereoDisplay()</a> or <a class="el" href="classQGLViewer.html#z93_6">toggleStereoDisplay()</a>. Default value is <code>false</code>.     </td>
  </tr>
</table>
<a name="z95_8" doxytag="QGLViewer::displayZBuffer"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void displayZBuffer </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [protected, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Displays the current z-buffer in grey levels for debugging purposes. Note that it hides the normal display. Frame rate is slowed down because of the z-buffer reading and writing.     </td>
  </tr>
</table>
<a name="z113_2" doxytag="QGLViewer::domElement"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> QDomElement domElement </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const QString &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>name</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>QDomDocument &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>doc</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates an XML QDomElement that represents the QGLViewer. <code>name</code> is the name of the QDomElement tag. You need to provide the QDomDocument <code>doc</code> that will hold the resulting element.
<p>
Use <a class="el" href="classQGLViewer.html#z113_3">initFromDOMElement()</a> to restore the QGLViewer state from the resulting domElement. Merges the <a class="el" href="classqglviewer_1_1ManipulatedFrame.html#z73_0">qglviewer::ManipulatedFrame::domElement()</a>, <a class="el" href="classqglviewer_1_1Camera.html#z23_0">qglviewer::Camera::domElement()</a>, ... elements.
<p>
<dl compact><dt><b>Attention: </b></dt><dd>
For the <a class="el" href="classQGLViewer.html#z91_1">manipulatedFrame()</a>, <a class="el" href="classqglviewer_1_1Frame.html#z45_0">qglviewer::Frame::constraint()</a> and <a class="el" href="classqglviewer_1_1Frame.html#z35_0">qglviewer::Frame::referenceFrame()</a> are not saved. See <a class="el" href="classqglviewer_1_1Frame.html#z51_0">qglviewer::Frame::domElement()</a>. </dl>    </td>
  </tr>
</table>
<a name="b6" doxytag="QGLViewer::draw"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void draw </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, protected, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The core function of the viewer, called to draw the scene.
<p>
If you build a class that inherits from QGLViewer, this is the function you want to overload. See the <a href="../examples/simpleViewer.html">simpleViewer</a> example for an illustration.
<p>
If you choose to use a callback mechanism instead, connect the <a class="el" href="classQGLViewer.html#j1">drawNeeded()</a> signal to your own draw function (signal emitted by <a class="el" href="classQGLViewer.html#b4">preDraw()</a>). See the <a href="../examples/callback.html">callback</a> example for details.
<p>
<dl compact><dt><b>Attention: </b></dt><dd>
The GL_PROJECTION matrix must not be modified by this function, so that the viewer hints (axis, grid, FPS...) that are displayed in <a class="el" href="classQGLViewer.html#b8">postDraw()</a> are correctly displayed. Use push/pop or call <a class="el" href="classQGLViewer.html#z91_0">camera()</a>-&gt;loadProjectionMatrix() at the end of <a class="el" href="classQGLViewer.html#b6">draw()</a> if you need to change the projection matrix (unlikely). The GL_MODELVIEW matrix, on the other hand, can be modified and left in a different state as it will be reloaded in <a class="el" href="classQGLViewer.html#b8">postDraw()</a> anyhow. </dl>    </td>
  </tr>
</table>
<a name="z95_5" doxytag="QGLViewer::draw3DText"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void draw3DText </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>pos</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>normal</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const QString &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>text</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>GLfloat&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>height</em> = 0.1f</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Although useful, this function is deprecated with recent Qt versions. Indeed, Qt renders text as pixmaps that cannot be orientated. However, when GLUT is used instead of Qt (when your Qt version is lower than 3.1, see QT_VERSION_WITHOUT_GLUT in <a class="el" href="config_8h.html">config.h</a>) orientated characters are possible and this function will work.
<p>
<code>pos</code> and <code>normal</code> respectly represent the 3D coordinate of the text and the normal to the text plane. They are expressed with respect to the <em>current</em> <code>GL_MODELVIEW</code> matrix.
<p>
If you want your text to always face the camera (normal parallel to <a class="el" href="classQGLViewer.html#z91_0">camera()</a>-&gt;viewDirection), use QGLWidget::renderText(x,y,z).
<p>
See the <a href="../examples/draw3DText.html">draw3DText</a> example for an illustration.     </td>
  </tr>
</table>
<a name="z95_0" doxytag="QGLViewer::drawAxis"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void drawAxis </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>size</em> = 1.0f          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Displays an XYZ axis, with a given size (default is 1.0). The axis position and orientation only depends on the current modelview matrix state. This code will display a translated and rotated axis (with respect to the world coordinates system, that can be displayed using the DRAW_AXIS shortcut key. Default key is 'A'). <div class="fragment"><pre>  glPushMatrix();
  glTranslatef(x,y,z);
  glRotatef(90.,0.,1.,0.);
  <a class="code" href="classQGLViewer.html#z95_0">drawAxis</a>(0.2);
  glPopMatrix();
</pre></div> Use the following code to display the current position and orientation of a <a class="el" href="classqglviewer_1_1Frame.html">qglviewer::Frame</a> : <div class="fragment"><pre>  glPushMatrix();
  glMultMatrixd(frame.matrix());
  <a class="code" href="classQGLViewer.html#z95_0">drawAxis</a>(0.2);
  glPopMatrix();
</pre></div>
<p>
<dl compact><dt><b>Note: </b></dt><dd>
The current matrix mode should be <code>GL_MODELVIEW</code>. </dl>    </td>
  </tr>
</table>
<a name="z95_1" doxytag="QGLViewer::drawGrid"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void drawGrid </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Displays a XY grid of size 1, centered on (0,0,0). The calling function should set the <code>GL_MODELVIEW</code> matrix and scale factor before calling this function.
<p>
<dl compact><dt><b>Attention: </b></dt><dd>
The GL state is modified by this function: <code>GL_LIGHTING</code> is disabled and line width is set to 1. </dl>    </td>
  </tr>
</table>
<a name="z95_6" doxytag="QGLViewer::drawLight"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void drawLight </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">GLenum&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>light</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>scale</em> = 1.0f</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [protected, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This debugging function draws a representation of <code>light</code>. The drawing depends on the type of light (spot, directional...). Typically used in your draw function: <div class="fragment"><pre>  <a class="code" href="classQGLViewer.html#z95_6">drawLight</a>(GL_LIGHT0)
</pre></div>
<p>
Optionnal parameter <code>scale</code> (default 1.0f) rescales the light representation. For instance, to get a size twice bigger:  <div class="fragment"><pre>  <a class="code" href="classQGLViewer.html#z95_6">drawLight</a>(GL_LIGHT0, 2.0f)
</pre></div> Note that this size is already proportional to the scene radius.
<p>
See the <a href="../examples/drawLight.html">drawLight</a> example for an illustration.     </td>
  </tr>
</table>
<a name="j1" doxytag="QGLViewer::drawNeeded"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void drawNeeded </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [signal]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Signal emitted by the default <a class="el" href="classQGLViewer.html#b6">QGLViewer::draw()</a> function. Connect this signal to your main drawing function. <a class="el" href="classQGLViewer.html#b4">preDraw()</a> is called <em>before</em> this signal is emitted and will call <a class="el" href="classqglviewer_1_1Camera.html#z15_0">qglviewer::Camera::loadProjectionMatrix()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z15_2">qglviewer::Camera::loadModelViewMatrix()</a> to set the viewing matrices. <a class="el" href="classQGLViewer.html#b8">postDraw()</a> will be called <em>after</em> this signal is answered. pre (resp. post) draw can be tuned by adding code at the beginning (resp. end) of your draw slot. See the <a href="../examples/callback.html">callback</a> example for an illustration.
<p>
You can check whether the camera is manipulated to call a fast draw version : <div class="fragment"><pre>  <span class="keywordflow">if</span> (viewer.camera()-&gt;isManipulated())
    fastDrawMethod();
  <span class="keywordflow">else</span>
    normalDrawMethod();
</pre></div>
<p>
Use this signal-slot mechanism ONLY IF you don't inherit your viewer from QGLViewer (in that case, simply overload the <a class="el" href="classQGLViewer.html#b6">draw()</a> and <a class="el" href="classQGLViewer.html#b7">fastDraw()</a> function).
<p>
See the <a href="../examples/fastDraw.html">fastDraw</a> example for an illustration.     </td>
  </tr>
</table>
<a name="z95_4" doxytag="QGLViewer::drawText"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void drawText </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const QString &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>text</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const QFont &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>fnt</em> = QFont()</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws a <code>text</code> at position <code>x</code>, <code>y</code> (expressed in screen coordinates pixels, origin in the upper left corner of the window). Can be called in <a class="el" href="classQGLViewer.html#b6">draw()</a> to easily display some information on the screen.
<p>
This procedure calls QGLWidget::renderText() if your Qt version is at least 3.1, otherwise it uses GLUT. The default QApplication::font() is used to render the text when no <code>fnt</code> is specified. Use QApplication::setFont() to define the default font. Only the font size (set with QFont::setPixelSize() or QFont::setPointSize()) is taken into with the GLUT version.
<p>
<dl compact><dt><b>Attention: </b></dt><dd>
<code>GL_LIGHTING</code> should be disabled by the calling function so that colors are properly rendered (with the renderText version).</dl>This function can be used in conjunction with the <a class="el" href="classqglviewer_1_1Camera.html#z19_0">qglviewer::Camera::projectedCoordinatesOf()</a> function to display a text attached to an object. In your <a class="el" href="classQGLViewer.html#b6">draw()</a> function call: <div class="fragment"><pre>  <a class="code" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> screenPos = <a class="code" href="classQGLViewer.html#z91_0">camera</a>()-&gt;<a class="code" href="classqglviewer_1_1Camera.html#z19_0">projectedCoordinatesOf</a>(myFrame.position());
  <a class="code" href="classQGLViewer.html#z95_4">drawText</a>((<span class="keywordtype">int</span>)screenPos[0], (<span class="keywordtype">int</span>)screenPos[1], <span class="stringliteral">"My Object"</span>);
</pre></div> See the <a href="../examples/screenCoordSystem.html">screenCoordSystem</a> example for an illustration.
<p>
QGLWidget::renderText() (Qt &gt;= 3.1) performs a similar action. It exists in a 2D (pixel coordinates) and a 3D (classical coordinates) version. Use this QGLWidget::renderText(x,y,z, str) function to draw a text that faces the camera, located at a specific 3D location (no need to convert to screen coordinates).
<p>
The <code>GL_MODELVIEW</code> and <code>GL_PROJECTION</code> matrices are not modified by this function.
<p>
Text is displayed only when <a class="el" href="classQGLViewer.html#z87_4">textIsEnabled()</a> is <code>true</code> (default). Use <a class="el" href="classQGLViewer.html#z87_15">toggleEnableText()</a> or <a class="el" href="classQGLViewer.html#z87_14">setEnableText()</a> to change this value (default ENABLE_TEXT shortcut key is '?'). This mechanism allows the user to conveniently remove all the displayed text with a shortcut key. Set the shortcut key to 0 if you want to forbid this behavior (see <a class="el" href="classQGLViewer.html#z109_0">setShortcutKey()</a>).
<p>
See also the <a class="el" href="classQGLViewer.html#z95_5">draw3DText()</a> and <a class="el" href="classQGLViewer.html#z95_7">displayFPS()</a> functions.
<p>
<dl compact><dt><b>Note: </b></dt><dd>
Each call to <a class="el" href="classQGLViewer.html#z95_4">drawText()</a> changes the camera projection matrix and restores it back (using <a class="el" href="classQGLViewer.html#z95_2">startScreenCoordinatesSystem()</a> and <a class="el" href="classQGLViewer.html#z95_3">stopScreenCoordinatesSystem()</a> with Qt &lt; 3.1). If you call this function several times and it slows down your frame rate, consider factorizing the context changes. You may also want to try the Qt image overlay mechanism which may be more efficient when your text does not change over time).</dl><dl compact><dt><b>Note: </b></dt><dd>
The Qt minimum version that disables glut is set by QT_VERSION_WITHOUT_GLUT in <a class="el" href="config_8h.html">config.h</a>. Default value is Qt 3.1. </dl>    </td>
  </tr>
</table>
<a name="z117_1" doxytag="QGLViewer::drawVisualHints"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void drawVisualHints </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Draws viewer related visual hints.
<p>
Displays the new <a class="el" href="classqglviewer_1_1Camera.html#z9_0">qglviewer::Camera::revolveAroundPoint()</a> when it is changed. See the <a href="../mouse.html">mouse page</a> for details. Also draws a line between <a class="el" href="classqglviewer_1_1Camera.html#z9_0">qglviewer::Camera::revolveAroundPoint()</a> and mouse cursor when the camera is rotated around the camera Z axis.
<p>
See also <a class="el" href="classQGLViewer.html#z117_0">setVisualHintsMask()</a> and <a class="el" href="classQGLViewer.html#z117_2">resetVisualHints()</a>. The hint color is <a class="el" href="classQGLViewer.html#z85_2">foregroundColor()</a>.
<p>
<dl compact><dt><b>Note: </b></dt><dd>
These functions may become more interesting one day. The current design is too limited and should be improved when other visual hints must be drawn. </dl>    </td>
  </tr>
</table>
<a name="z107_3" doxytag="QGLViewer::drawWithNames"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void drawWithNames </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function is called by <a class="el" href="classQGLViewer.html#z107_0">select()</a> and is originally empty. You should overload it to draw the different elements of your scene you want to be able to select. The default <a class="el" href="classQGLViewer.html#z107_0">select()</a> implementation relies on the <code>GL_SELECT</code>, and requires the drawing of each element within <code>glPushName()</code> <code>glPopName()</code> block. A typical usage would be (see the <a href="../examples/select.html">select</a> example): <div class="fragment"><pre>    <span class="keywordtype">void</span> Viewer::drawWithNames()
    {
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;nbObjects; ++i)
      {
        glPushName(i);
        object(i)-&gt;draw();
        glPopName();
      }
    }
</pre></div>
<p>
The resulting selected name is retrieved by <a class="el" href="classQGLViewer.html#z107_4">endSelection()</a>, which <a class="el" href="classQGLViewer.html#z107_7">setSelectedName()</a> (a value of -1 means no selection). Use <a class="el" href="classQGLViewer.html#z107_6">selectedName()</a> to update your selection, probably in the <a class="el" href="classQGLViewer.html#z107_5">postSelection()</a> method.     </td>
  </tr>
</table>
<a name="z87_16" doxytag="QGLViewer::editCameraPath"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void editCameraPath </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>edit</em> = true          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start (default, <code>edit=\p</code> true) or stop (<code>edit=\p</code> false) the edition of the camera paths. See also <a class="el" href="classQGLViewer.html#z87_17">toggleCameraPathEditor()</a>.     </td>
  </tr>
</table>
<a name="z107_4" doxytag="QGLViewer::endSelection"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void endSelection </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>y</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method is called by <a class="el" href="classQGLViewer.html#z107_0">select()</a> after scene elements were drawned by <a class="el" href="classQGLViewer.html#z107_3">drawWithNames()</a>. It should analyse the selection result to determine which object is actually selected.
<p>
The default implementation relies on <code>GL_SELECT</code> mode (see <a class="el" href="classQGLViewer.html#z107_2">beginSelection()</a>). It assumes that names were pushed and popped in <a class="el" href="classQGLViewer.html#z107_3">drawWithNames()</a>, and analyses the <a class="el" href="classQGLViewer.html#z107_12">selectBuffer()</a> to find the name that corresponds to the closer (z min) object. It then <a class="el" href="classQGLViewer.html#z107_7">setSelectedName()</a> to this value, or to -1 if the <a class="el" href="classQGLViewer.html#z107_12">selectBuffer()</a> is empty (no object under the mouse cursor). Use <a class="el" href="classQGLViewer.html#z107_6">selectedName()</a> (probably in the <a class="el" href="classQGLViewer.html#z107_5">postSelection()</a> method) to retrieve this value and update your data structure accordingly.
<p>
This default implementation, although sufficient for many cases is however limited and you may have to overload this method. This will be the case if <a class="el" href="classQGLViewer.html#z107_3">drawWithNames()</a> uses several push levels in the name heap. A more precise depth selection, for instance priviledging points over edges and triangles to avoir z precision problems, will also require an overloading. A typical implementation will look like: <div class="fragment"><pre>  glFlush();

  <span class="comment">// Get the number of objects that were seen through the pick matrix frustum. Reset GL_RENDER mode.</span>
  GLint nbHits = glRenderMode(GL_RENDER);

  <span class="keywordflow">if</span> (nbHits &lt;= 0)
    <a class="code" href="classQGLViewer.html#z107_7">setSelectedName</a>(-1);
  <span class="keywordflow">else</span>
    {
      <span class="comment">// Interpret results : each object created values in the selectBuffer().</span>
      <span class="comment">// See the glSelectBuffer() man page for details on the buffer structure.</span>
      <span class="comment">// The following code depends on your selectBuffer() structure.</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;nbHits; ++i)
       <span class="keywordflow">if</span> ((<a class="code" href="classQGLViewer.html#z107_12">selectBuffer</a>())[i*4+1] &lt; zMin)
         <a class="code" href="classQGLViewer.html#z107_7">setSelectedName</a>((<a class="code" href="classQGLViewer.html#z107_12">selectBuffer</a>())[i*4+3])
    }
</pre></div>     </td>
  </tr>
</table>
<a name="b7" doxytag="QGLViewer::fastDraw"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void fastDraw </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Fast draw of the scene. Called instead of <a class="el" href="classQGLViewer.html#b6">draw()</a> when the camera is manipulated. Useful for interactive displacements in a complex scene. Default behavior calls <a class="el" href="classQGLViewer.html#b6">draw()</a>. See the <a href="../examples/fastDraw.html">fastDraw</a> example for an illustration.     </td>
  </tr>
</table>
<a name="z85_2" doxytag="QGLViewer::foregroundColor"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> foregroundColor </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The current viewer foreground color. This color is used to display the FPS text (see <a class="el" href="classQGLViewer.html#z87_10">setDisplayFPS()</a>), camera paths (see <a class="el" href="classqglviewer_1_1Camera.html#z11_7">qglviewer::Camera::drawAllPaths()</a> and <a class="el" href="classQGLViewer.html#z87_16">editCameraPath()</a>), XY grid (see <a class="el" href="classQGLViewer.html#z95_1">drawGrid()</a> and <a class="el" href="classQGLViewer.html#z87_8">setDrawGrid()</a>) and the visual hints (see <a class="el" href="classQGLViewer.html#z117_1">drawVisualHints()</a>).
<p>
Default value is (0.7, 0.7, 0.7). Each color component ranges between 0.0 and 1.0 (see the <code>glColor3f()</code> documentation). This value should be changed in conjunction with the <a class="el" href="classQGLViewer.html#z85_0">backgroundColor()</a> (see <a class="el" href="classQGLViewer.html#z85_4">setBackgroundColor()</a>).
<p>
See also the QGLWidget::qglColor() and QGLWidget::qglClearColor() documentations.     </td>
  </tr>
</table>
<a name="j6" doxytag="QGLViewer::fpsDisplayed"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void fpsDisplayed </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>on</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [signal]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This signal is emitted whenever <a class="el" href="classQGLViewer.html#z87_2">fpsIsDisplayed()</a> changes value. This can be done with <a class="el" href="classQGLViewer.html#z87_10">setDisplayFPS()</a> or <a class="el" href="classQGLViewer.html#z87_11">toggleDisplayFPS()</a>.     </td>
  </tr>
</table>
<a name="z87_2" doxytag="QGLViewer::fpsIsDisplayed"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool fpsIsDisplayed </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns <code>true</code> if a <a class="el" href="classQGLViewer.html#z95_7">displayFPS()</a> is called by the viewer. Set by <a class="el" href="classQGLViewer.html#z87_10">setDisplayFPS()</a> or <a class="el" href="classQGLViewer.html#z87_11">toggleDisplayFPS()</a>. See <a class="el" href="classQGLViewer.html#z89_4">currentFPS()</a>.     </td>
  </tr>
</table>
<a name="z85_1" doxytag="QGLViewer::getBackgroundColor"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void getBackgroundColor </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>r</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>g</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>b</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as <a class="el" href="classQGLViewer.html#z85_0">backgroundColor()</a>, but result is returned as three floats.     </td>
  </tr>
</table>
<a name="z111_8" doxytag="QGLViewer::getClickButtonState"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void getClickButtonState </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classQGLViewer.html#z111_14">ClickAction</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>ca</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Qt::ButtonState &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>buttonState</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>doubleClick</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Qt::ButtonState &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>buttonBefore</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Similar to <a class="el" href="classQGLViewer.html#z111_5">mouseButtonState()</a>, but for the click actions. Note that the results of the query are returned in the <code>buttonState</code>, <code>doubleClick</code> and <code>buttonBefore</code> parameters. If the ClickAction is not associated to any mouse button, <code>Qt::NoButton</code> is returned in <code>buttonState</code>. If several mouse buttons trigger in the ClickAction, one of them is returned.     </td>
  </tr>
</table>
<a name="z85_3" doxytag="QGLViewer::getForegroundColor"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void getForegroundColor </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>r</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>g</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>b</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as <a class="el" href="classQGLViewer.html#z85_2">foregroundColor()</a>, but result is returned as three floats.     </td>
  </tr>
</table>
<a name="z89_2" doxytag="QGLViewer::getSceneCenter"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void getSceneCenter </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>z</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
float version of sceneCenter().     </td>
  </tr>
</table>
<a name="j5" doxytag="QGLViewer::gridDrawn"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void gridDrawn </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>on</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [signal]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This signal is emitted whenever <a class="el" href="classQGLViewer.html#z87_1">gridIsDrawn()</a> changes value. This can be done with <a class="el" href="classQGLViewer.html#z87_8">setDrawGrid()</a> or <a class="el" href="classQGLViewer.html#z87_9">toggleDrawGrid()</a>.     </td>
  </tr>
</table>
<a name="z87_1" doxytag="QGLViewer::gridIsDrawn"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool gridIsDrawn </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns <code>true</code> if a grid is drawn by the viewer. Set by <a class="el" href="classQGLViewer.html#z87_8">setDrawGrid()</a> or <a class="el" href="classQGLViewer.html#z87_9">toggleDrawGrid()</a>.     </td>
  </tr>
</table>
<a name="z103_3" doxytag="QGLViewer::help"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void help </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function is called when the user presses the HELP_KEY (default is H). It opens a modal help window that includes three tabs, which are respectively filled with the results of <a class="el" href="classQGLViewer.html#z103_0">helpString()</a>, <a class="el" href="classQGLViewer.html#z103_2">shortcutBindingsString()</a> and <a class="el" href="classQGLViewer.html#z103_1">mouseBindingsString()</a>. If one of these is QString::null, the associated tab is not created. Overload these functions to define you own help text. Rich html-like text can be used.
<p>
Set the HELP_KEY shortcut key to 0 to disable the help window (see <a class="el" href="classQGLViewer.html#z109_0">setShortcutKey()</a>).
<p>
The <a class="el" href="classQGLViewer.html#j3">helpRequired()</a> signal is emitted.     </td>
  </tr>
</table>
<a name="j3" doxytag="QGLViewer::helpRequired"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void helpRequired </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [signal]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Signal emitted by the default <a class="el" href="classQGLViewer.html#z103_3">QGLViewer::help()</a> function. Connect this signal to your own help function.
<p>
Use this signal-slot mechanism ONLY IF you don't inherit your viewer from QGLViewer (in that case, simply overload the <a class="el" href="classQGLViewer.html#z103_3">help()</a> function).     </td>
  </tr>
</table>
<a name="z103_0" doxytag="QGLViewer::helpString"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual QString helpString </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classQGLViewer.html#z103_0">helpString()</a> is displayed in the help window main tab. This window is created by the <a class="el" href="classQGLViewer.html#z103_3">help()</a> function when the HELP_KEY (default is 'H') is pressed. Overload this function to define your own help string, which should shortly describe your application and explains how it works. Rich-text (HTML) tags can be used. <div class="fragment"><pre>  QString myViewer::helpString()<span class="keyword"> const</span>
<span class="keyword">  </span>{
    QString text(<span class="stringliteral">"&lt;h2&gt;M y V i e w e r&lt;/h2&gt;"</span>);
    text += <span class="stringliteral">"Displays a &lt;b&gt;Scene&lt;/b&gt; using openGL. Move the camera using the mouse."</span>;
    <span class="keywordflow">return</span> text;
  }
</pre></div>
<p>
Default value is QString::null, which means that the associated tab in the help window is removed.
<p>
See also <a class="el" href="classQGLViewer.html#z103_1">mouseBindingsString()</a> and <a class="el" href="classQGLViewer.html#z103_2">shortcutBindingsString()</a>.     </td>
  </tr>
</table>
<a name="b2" doxytag="QGLViewer::init"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void init </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, protected, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialization of the viewer. This function will be called before the first drawing and you can overload it to initialize some of the GL flags. The original function is empty and hence does not need to be called.
<p>
Can be used to set the camera (<a class="el" href="classqglviewer_1_1Camera.html#z1_4">qglviewer::Camera::setPosition()</a>, <a class="el" href="classqglviewer_1_1Camera.html#z5_4">qglviewer::Camera::setFieldOfView()</a>, ...) or to make the camera fit the scene (see <a class="el" href="classqglviewer_1_1Camera.html#z3_1">qglviewer::Camera::showEntireScene()</a>).
<p>
OpenGL flags should also be (re)defined here. Some default flags are set in <a class="el" href="classQGLViewer.html#b1">initializeGL()</a>: only the <code>glEnable(GL_COLOR_MATERIAL)</code> and <code>glEnable(GL_LIGHTING)</code> are not set to their OpenGL default value. Use this function to set your own openGL flags.
<p>
<dl compact><dt><b>Attention: </b></dt><dd>
You should not call updateGL() (or any function that calls it) in this function, as it will create an infinite loop (this comes from the Qt <a class="el" href="classQGLViewer.html#b1">initializeGL()</a> function). The different QGLViewer set function (<a class="el" href="classQGLViewer.html#z87_8">setDrawGrid()</a>, <a class="el" href="classQGLViewer.html#z87_6">setDrawAxis()</a>...) are protected against this problem and can safely be called.</dl><dl compact><dt><b>Attention: </b></dt><dd>
This function should only be used for viewer dependent initializations (camera, openGL state). Other data initializations (program parameters parsing, scene dependent initializations...) should be made in a separate function, called by your <code>main</code> or any other initialization function. On the other hand, all the openGL specific initializations <em>must</em> be done in this function: the openGL context is not yet available in your viewer constructor. </dl>    </td>
  </tr>
</table>
<a name="z113_3" doxytag="QGLViewer::initFromDOMElement"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void initFromDOMElement </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const QDomElement &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>de</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Restores the QGLViewer state from a QDomElement created by <a class="el" href="classQGLViewer.html#z113_2">domElement()</a>. See also <a class="el" href="classqglviewer_1_1Camera.html#z23_1">qglviewer::Camera::initFromDOMElement()</a>, <a class="el" href="classqglviewer_1_1ManipulatedFrame.html#z73_1">qglviewer::ManipulatedFrame::initFromDOMElement()</a>.
<p>
<dl compact><dt><b>Note: </b></dt><dd>
<a class="el" href="classQGLViewer.html#z93_1">isFullScreen()</a> cannot be properly restored in constructor or in <a class="el" href="classQGLViewer.html#b2">init()</a>. It requires <a class="el" href="classQGLViewer.html#b1">initializeGL()</a> to be completed before. </dl>    </td>
  </tr>
</table>
<a name="b1" doxytag="QGLViewer::initializeGL"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void initializeGL </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialization of the GL context, creation of some viewer display lists. Calls <a class="el" href="classQGLViewer.html#b2">init()</a> at the end.
<p>
<dl compact><dt><b>Attention: </b></dt><dd>
The initial QGLViewer GL state does <em>not</em> follow the openGL standards. Actually, to make beginners' life easier and to simplify the examples, the following flags are defined :</dl><div class="fragment"><pre>  glEnable(GL_LIGHTING);
  glEnable(GL_LIGHT0);
  glEnable(GL_DEPTH_TEST);
  glEnable(GL_COLOR_MATERIAL);
</pre></div>
<p>
If you port an existing application to QGLViewer and your display changes, you probably want to disable these flags (in <a class="el" href="classQGLViewer.html#b2">init()</a>) to get back to a standard openGL state.
<p>
<a class="el" href="classQGLViewer.html#b2">init()</a> is called at the end, and the openGL flags can be re-defined there. This function should not be overloaded. Use <a class="el" href="classQGLViewer.html#b2">init()</a> for viewer initialization. In case of overloading, you should call <a class="el" href="classQGLViewer.html#b1">QGLViewer::initializeGL()</a> at the beginning of your new <a class="el" href="classQGLViewer.html#b1">initializeGL()</a> function (display list creation).     </td>
  </tr>
</table>
<a name="z93_1" doxytag="QGLViewer::isFullScreen"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool isFullScreen </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns <code>true</code> if the viewer is in fullScreen mode. Set by <a class="el" href="classQGLViewer.html#z93_3">setFullScreen()</a> or <a class="el" href="classQGLViewer.html#z93_4">toggleFullScreen()</a>.     </td>
  </tr>
</table>
<a name="z109_5" doxytag="QGLViewer::keyFrameKey"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> Qt::Key keyFrameKey </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>nb</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the camera Key Frame path shortcut key for index <code>nb</code>. <code>nb</code> should not exceed <a class="el" href="classqglviewer_1_1Camera.html#z11_0">qglviewer::Camera::nbPaths()</a>. Default values are F1..F12 for indexes 0..11. See <a class="el" href="classQGLViewer.html#z109_4">setKeyFrameKey()</a> for details.
<p>
See also <a class="el" href="classQGLViewer.html#z109_7">addKeyFrameStateKey()</a> and <a class="el" href="classQGLViewer.html#z109_9">playKeyFramePathStateKey()</a>.
<p>
See the <a href="../shortcuts.html">QGLViewer shortcuts page</a> for details.     </td>
  </tr>
</table>
<a name="z105_7" doxytag="QGLViewer::keyPressEvent"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void keyPressEvent </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">QKeyEvent *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>e</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Key pressed callback function. Some default key bindings are implemented and can easily be redefined using <a class="el" href="classQGLViewer.html#z109_0">setShortcutKey()</a> and <a class="el" href="classQGLViewer.html#z109_2">setShortcutStateKey()</a>. See the <a href="../shortcuts.html">QGLViewer shortcuts page</a> for details and default values.
<p>
Overload this function to implement a specific shortcut key binding for one of your application function. You should call the original function in the default case of your switch to preserve the default viewer key bindings : <div class="fragment"><pre>  <span class="keywordtype">void</span> Viewer::keyPressEvent(QKeyEvent *e)
  {
  <span class="keywordflow">switch</span> (e-&gt;key())
  {
  <span class="keywordflow">case</span> Qt::Key_R : reset(); updateGL(); <span class="keywordflow">break</span>;
  <span class="comment">// and so on...</span>
  <span class="keywordflow">default</span>: <a class="code" href="classQGLViewer.html#z105_7">QGLViewer::keyPressEvent</a>(e);
  }
  }
</pre></div>
<p>
Consider testing the modifier keys for more complex behaviors: <div class="fragment"><pre>  <span class="keyword">const</span> Qt::ButtonState state = (Qt::ButtonState)(e-&gt;state() &amp; Qt::KeyButtonMask);
  <span class="keywordflow">if</span> (state == Qt::AltButton)
  <span class="keywordflow">switch</span> (e-&gt;key())
  {
  ...
  }
  <span class="keywordflow">else</span>
  ...
</pre></div>     </td>
  </tr>
</table>
<a name="z91_1" doxytag="QGLViewer::manipulatedFrame"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classqglviewer_1_1ManipulatedFrame.html">qglviewer::ManipulatedFrame</a>* manipulatedFrame </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the current manipulated frame, which can be moved with the mouse. Default mouse bindings make the ManipulatedFrame move when the <code>Control</code> key is pressed. Use <a class="el" href="classQGLViewer.html#z111_2">setMouseBinding()</a> to define your own bindings.
<p>
Returns <code>NULL</code> when no frame has been associated with the viewer (with <a class="el" href="classQGLViewer.html#z91_3">setManipulatedFrame()</a>). See the <a href="../examples/manipulatedFrame.html">manipulatedFrame</a> example for an illustration.     </td>
  </tr>
</table>
<a name="z111_3" doxytag="QGLViewer::mouseAction"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classQGLViewer.html#z111_0">QGLViewer::MouseAction</a> mouseAction </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>buttonState</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the MouseAction currently associated with the Qt::ButtonState <code>buttonState</code>. If no action is associated, returns NO_MOUSE_ACTION.
<p>
For instance, to know which motion corresponds to Alt-LeftButton, do: <div class="fragment"><pre>  <a class="code" href="classQGLViewer.html#z111_0">QGLViewer::MouseAction</a> mm = <a class="code" href="classQGLViewer.html#z111_3">mouseAction</a>(Qt::AltButton | Qt::LeftButton);
  <span class="keywordflow">if</span> (mm != <a class="code" href="classQGLViewer.html#z111_0s0">NO_MOUSE_ACTION</a>) ...
</pre></div>
<p>
Use <a class="el" href="classQGLViewer.html#z111_4">mouseHandler()</a> to know who (CAMERA or FRAME) will perform this motion.     </td>
  </tr>
</table>
<a name="z103_1" doxytag="QGLViewer::mouseBindingsString"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> QString mouseBindingsString </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns a QString that describes the application mouse bindings, and that will be displayed in one of the <a class="el" href="classQGLViewer.html#z103_3">help()</a> window tabs. Default value is a table that describes all the current mouse bindings. See <a class="el" href="classQGLViewer.html#z111_2">setMouseBinding()</a>, <a class="el" href="classQGLViewer.html#z111_9">setWheelBinding()</a> and the <a href="../mouse.html">QGLViewer mouse page</a> for details on mouse bindings.
<p>
Overload this function to add your application specific mouse bindings. See <a class="el" href="classQGLViewer.html#z103_2">shortcutBindingsString()</a> for a complete example.
<p>
A QString::null value will suppress the "Shortcuts" tab in <a class="el" href="classQGLViewer.html#z103_3">help()</a>.     </td>
  </tr>
</table>
<a name="z111_5" doxytag="QGLViewer::mouseButtonState"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> Qt::ButtonState mouseButtonState </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classQGLViewer.html#z111_13">MouseHandler</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>mh</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classQGLViewer.html#z111_0">MouseAction</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>ma</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>withConstraint</em> = true</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the Qt::ButtonState (if any) that has to be used to activate action <code>ma</code> on handler <code>mh</code> (with constraint or not). If no Qt::ButtonState is associated, returns Qt::NoButton which is an impossible case since at least one mouse button has to be specified in <a class="el" href="classQGLViewer.html#z111_2">setMouseBinding()</a>.
<p>
To know which keys and mouse buttons have to be pressed to translate the camera, use tests like: <div class="fragment"><pre>  Qt::ButtonState bs = <a class="code" href="classQGLViewer.html#z111_5">mouseButtonState</a>(<a class="code" href="classQGLViewer.html#z111_13t13">QGLViewer::CAMERA</a>, <a class="code" href="classQGLViewer.html#z111_0s3">QGLViewer::TRANSLATE</a>);
  <span class="keywordflow">if</span> (bs &amp; Qt::RightButton) ... <span class="comment">// Right button needed to translate the camera</span>
  <span class="keywordflow">if</span> (bs &amp; Qt::AltButton)   ... <span class="comment">// Alt key needed</span>
  <span class="keywordflow">if</span> (bs &amp; Qt::KeyButtonMask == Qt::NoButton) ... <span class="comment">// No state key needed</span>
</pre></div> Note that current mouse bindings are displayed by one of the help window tabs (use the 'H' key).     </td>
  </tr>
</table>
<a name="z105_1" doxytag="QGLViewer::mouseDoubleClickEvent"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void mouseDoubleClickEvent </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">QMouseEvent *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>e</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The behavior of the mouse double click depends on the current mouse binding. See <a class="el" href="classQGLViewer.html#z111_2">setMouseBinding()</a> and the <a href="../mouse.html">QGLViewer mouse page</a>.     </td>
  </tr>
</table>
<a name="z97_0" doxytag="QGLViewer::mouseGrabber"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classqglviewer_1_1MouseGrabber.html">qglviewer::MouseGrabber</a>* mouseGrabber </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the current MouseGrabber, or <code>NULL</code> if no MouseGrabber is currently under the mouse cursor. When <a class="el" href="classqglviewer_1_1MouseGrabber.html#z79_1">qglviewer::MouseGrabber::grabsMouse()</a>, the different mouse events are sent to the <a class="el" href="classQGLViewer.html#z97_0">mouseGrabber()</a> (see <a class="el" href="classQGLViewer.html#z105_0">mousePressEvent()</a>, <a class="el" href="classQGLViewer.html#z105_3">mouseMoveEvent()</a>, and related functions.)
<p>
You may use <a class="el" href="classQGLViewer.html#z97_1">setMouseGrabber()</a> to define a <a class="el" href="classqglviewer_1_1MouseGrabber.html">qglviewer::MouseGrabber</a>, but <a class="el" href="classQGLViewer.html#z105_3">mouseMoveEvent()</a> already does it, using <a class="el" href="classqglviewer_1_1MouseGrabber.html#z79_0">qglviewer::MouseGrabber::checkIfGrabsMouse()</a> to determine if a MouseGrabber is currently under the mouse cursor. See the <a href="../examples/mouseGrabber.html">mouseGrabber</a> example for an illustration.
<p>
In order to use mouseGrabber, you need to enable mouse tracking so that <a class="el" href="classQGLViewer.html#z105_3">mouseMoveEvent()</a> is called even when no mouse button is pressed. Add this in <a class="el" href="classQGLViewer.html#b2">init()</a> or in your viewer constructor: <div class="fragment"><pre>  setMouseTracking(<span class="keyword">true</span>);
</pre></div> Note that the default behavior is to <em>disable</em> mouse tracking. Use QWidget::hasMouseTracking() to get current value.     </td>
  </tr>
</table>
<a name="z111_4" doxytag="QGLViewer::mouseHandler"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int mouseHandler </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>buttonState</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the MouseHandler currently associated with the Qt::ButtonState <code>buttonState</code>. If no action is associated, returns <code>-1</code>.
<p>
For instance, to know which handler receives the Alt-LeftButton, do: <div class="fragment"><pre>  <span class="keywordtype">int</span> mh = <a class="code" href="classQGLViewer.html#z111_4">mouseHandler</a>(Qt::AltButton | Qt::LeftButton);
  <span class="keywordflow">if</span> (mh == <a class="code" href="classQGLViewer.html#z111_13t13">QGLViewer::CAMERA</a>) ...
</pre></div>
<p>
Use <a class="el" href="classQGLViewer.html#z111_3">mouseAction()</a> to know which action (see the MouseAction enum) will be perform on this handler.     </td>
  </tr>
</table>
<a name="z105_3" doxytag="QGLViewer::mouseMoveEvent"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void mouseMoveEvent </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">QMouseEvent *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>e</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Maintaining a button pressed while moving the mouse updates the camera or the manipulated frame. The different possible actions (see MouseAction) are binded to mouse buttons using <a class="el" href="classQGLViewer.html#z111_2">setMouseBinding()</a>.
<p>
If you want to define your <em>own</em> mouse behavior, do something like this : <div class="fragment"><pre>  <span class="keywordtype">void</span> Viewer::mousePressEvent(QMouseEvent* e)
  {
  <span class="comment">// Qt::KeyButtonMask separates the Control/Alt/Shift state key from the mouse (left/middle/right) buttons</span>
  <span class="keywordflow">if</span> ((e-&gt;state() &amp; Qt::KeyButtonMask) == (Your personal Qt::ShiftButton/Qt::ControlButton/Qt::AltButton combination))
    myMouseBehavior = <span class="keyword">true</span>;
  <span class="keywordflow">else</span>
    <a class="code" href="classQGLViewer.html#z105_0">QGLViewer::mousePressEvent</a>(e);
  }

  <span class="keywordtype">void</span> Viewer::mouseMoveEvent(QMouseEvent *e)
  {
  <span class="keywordflow">if</span> (myMouseBehavior)
    <span class="comment">// Use e-&gt;x() and e-&gt;y() as you want...</span>
  <span class="keywordflow">else</span>
    <a class="code" href="classQGLViewer.html#z105_3">QGLViewer::mouseMoveEvent</a>(e);
  }

  <span class="keywordtype">void</span> Viewer::mouseReleaseEvent(QMouseEvent* e)
  {
  <span class="keywordflow">if</span> (myMouseBehavior)
    myMouseBehavior = <span class="keyword">false</span>;
  <span class="keywordflow">else</span>
    <a class="code" href="classQGLViewer.html#z105_2">QGLViewer::mouseReleaseEvent</a>(e);
  }
</pre></div>
<p>
Many other event handlers can be customized : <a class="el" href="classQGLViewer.html#z105_1">mouseDoubleClickEvent()</a>, <a class="el" href="classQGLViewer.html#z105_4">wheelEvent()</a>, <a class="el" href="classQGLViewer.html#z105_2">mouseReleaseEvent()</a>... See the Qt::QWidget protected members documentation for a complete list.     </td>
  </tr>
</table>
<a name="z105_0" doxytag="QGLViewer::mousePressEvent"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void mousePressEvent </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">QMouseEvent *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>e</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
When the user clicks on the mouse: <ul>
<li> if a <a class="el" href="classQGLViewer.html#z97_0">mouseGrabber()</a> is defined, <a class="el" href="classqglviewer_1_1MouseGrabber.html#z83_0">qglviewer::MouseGrabber::mousePressEvent()</a> is called, <li> otherwise, the <a class="el" href="classQGLViewer.html#z91_0">camera()</a> or the <a class="el" href="classQGLViewer.html#z91_1">manipulatedFrame()</a> interprets the mouse displacements, depending on current mouse bindings.</ul>
See the <a href="../mouse.html">QGLViewer mouse page</a> for a complete description of mouse bindings. If you need to implement a scene object selection with the mouse, see the <a href="../examples/select.html">select</a> example and <a class="el" href="classqglviewer_1_1Camera.html#z19_4">qglviewer::Camera::convertClickToLine()</a>.
<p>
Classical mouse binding customization can be achieved using <a class="el" href="classQGLViewer.html#z111_2">setMouseBinding()</a> and <a class="el" href="classQGLViewer.html#z111_9">setWheelBinding()</a>.
<p>
See the <a class="el" href="classQGLViewer.html#z105_3">mouseMoveEvent()</a> documentation for an example of more complex mouse behavior customization.
<p>
<dl compact><dt><b>Note: </b></dt><dd>
When the <a class="el" href="classQGLViewer.html#z97_0">mouseGrabber()</a> is a <a class="el" href="classQGLViewer.html#z91_1">manipulatedFrame()</a>, the modifier keys are not taken into account. This allows for a direct manipulation of the <a class="el" href="classQGLViewer.html#z91_1">manipulatedFrame()</a> when the mouse hovers, which is probably what is expected. </dl>    </td>
  </tr>
</table>
<a name="z105_2" doxytag="QGLViewer::mouseReleaseEvent"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void mouseReleaseEvent </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">QMouseEvent *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>e</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
When the user releases the mouse button, the camera (or the manipulatedFrame) action is stopped.
<p>
See the <a class="el" href="classQGLViewer.html#z105_3">mouseMoveEvent()</a> documentation for an example of mouse behavior customization.     </td>
  </tr>
</table>
<a name="b3" doxytag="QGLViewer::paintGL"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void paintGL </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The paint method. Calls <a class="el" href="classQGLViewer.html#b4">preDraw()</a>, <a class="el" href="classQGLViewer.html#b6">draw()</a> (or <a class="el" href="classQGLViewer.html#b7">fastDraw()</a>) and <a class="el" href="classQGLViewer.html#b8">postDraw()</a> in that order. Should not be overloaded. Overload the internal functions instead.
<p>
If you choose to overload, the <code>GL_Context</code> must not be changed between two successive calls to <a class="el" href="classQGLViewer.html#b6">draw()</a>, so that the user can feel free to set his/her openGL flags once for all.
<p>
If viewer <a class="el" href="classQGLViewer.html#z93_2">displaysInStereo()</a>, calls preDrawStereo(flag), <a class="el" href="classQGLViewer.html#b6">draw()</a>, <a class="el" href="classQGLViewer.html#b8">postDraw()</a>, first with flag = <code>true</code> and then flag = <code>false</code> to draw successively in left and right buffers.     </td>
  </tr>
</table>
<a name="z109_9" doxytag="QGLViewer::playKeyFramePathStateKey"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> Qt::ButtonState playKeyFramePathStateKey </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the state key (Qt::AltButton, Qt::ShiftButton, Qt::ControlButton) that must be pressed with the <a class="el" href="classQGLViewer.html#z109_5">keyFrameKey()</a> to <em>play</em> a camera KeyFrame path. Default value is Qt::NoButton. See <a class="el" href="classQGLViewer.html#z109_8">setPlayKeyFramePathStateKey()</a> for details.
<p>
See also <a class="el" href="classQGLViewer.html#z109_5">keyFrameKey()</a> and <a class="el" href="classQGLViewer.html#z109_7">addKeyFrameStateKey()</a>.
<p>
See the <a href="../shortcuts.html">QGLViewer shortcuts page</a> for details.     </td>
  </tr>
</table>
<a name="j11" doxytag="QGLViewer::pointSelected"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pointSelected </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const QMouseEvent *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>e</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [signal]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Signal emitted when <a class="el" href="classQGLViewer.html#z107_0">select()</a> is called. Connect this signal to your selection drawing function. Use this signal-slot mechanism ONLY IF you don't inherit your viewer from QGLViewer (in that case, simply overload the <a class="el" href="classQGLViewer.html#z107_0">select()</a> or the <a class="el" href="classQGLViewer.html#z107_3">drawWithNames()</a> functions). See <a class="el" href="classQGLViewer.html#z107_0">select()</a> for more details.     </td>
  </tr>
</table>
<a name="b8" doxytag="QGLViewer::postDraw"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void postDraw </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Done after <a class="el" href="classQGLViewer.html#b6">draw()</a>. Default behavior displays axis, grid, FPS... when the respective flags are enabled. The GLContext (color, LIGHTING, BLEND...) should <em>not</em> be changed by this function, so that in <a class="el" href="classQGLViewer.html#b6">draw()</a>, you can rely on the OpenGL context. Respect this convention (by pushing/popping the different attributes) if you overload this function. Assumes the <code>GL_PROJECTION</code> matrix was not changed by <a class="el" href="classQGLViewer.html#b6">draw()</a>, reset the <code>GL_MODELVIEW</code> matrix.     </td>
  </tr>
</table>
<a name="z107_5" doxytag="QGLViewer::postSelection"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void postSelection </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp;, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method is called at the end of the <a class="el" href="classQGLViewer.html#z107_0">select()</a> procedure. It should finalyse the selection process and update the data structure/interface/computation/display... according to the newly selected entity.
<p>
The default implementation is empty. Overload this method if needed, and use <a class="el" href="classQGLViewer.html#z107_6">selectedName()</a> to retrieve the selected entity name (returns -1 if no object was selectable under the mouse cursor). See the <a href="../examples/select.html">select</a> example for an illustration.     </td>
  </tr>
</table>
<a name="b4" doxytag="QGLViewer::preDraw"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void preDraw </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Called before <a class="el" href="classQGLViewer.html#b6">draw()</a>. Default behavior clears screen and set the projection and model view matrices : <div class="fragment"><pre>  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);    

  <span class="comment">// GL_PROJECTION matrix</span>
  <a class="code" href="classQGLViewer.html#z91_0">camera</a>()-&gt;<a class="code" href="classqglviewer_1_1Camera.html#z15_0">loadProjectionMatrix</a>();
  <span class="comment">// GL_MODELVIEW matrix</span>
  <a class="code" href="classQGLViewer.html#z91_0">camera</a>()-&gt;<a class="code" href="classqglviewer_1_1Camera.html#z15_2">loadModelViewMatrix</a>();
</pre></div>
<p>
Emits the <a class="el" href="classQGLViewer.html#j1">drawNeeded()</a> signal once this is done. Mainly useful if you choose not to use derivation to create your own viewer. See the <a href="../examples/callback.html">callback</a> example for details     </td>
  </tr>
</table>
<a name="b5" doxytag="QGLViewer::preDrawStereo"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void preDrawStereo </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>leftBuffer</em> = true          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Called before <a class="el" href="classQGLViewer.html#b6">draw()</a> (instead of <a class="el" href="classQGLViewer.html#b4">preDraw()</a>) when viewer <a class="el" href="classQGLViewer.html#z93_2">displaysInStereo()</a>. Same as <a class="el" href="classQGLViewer.html#b4">preDraw()</a> except that the glDrawBuffer() is set to <code>GL_BACK_LEFT</code> or <code>GL_BACK_RIGHT</code> depending on <code>leftBuffer</code>.     </td>
  </tr>
</table>
<a name="z89_1" doxytag="QGLViewer::QGLViewer::sceneCenter"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> QGLViewer::sceneCenter </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Scene should be included in a sphere centered on this point. Simply calls <a class="el" href="classqglviewer_1_1Camera.html#z25_1">qglviewer::Camera::sceneCenter()</a>. Set using <a class="el" href="classQGLViewer.html#z89_6">setSceneCenter()</a>.     </td>
  </tr>
</table>
<a name="z115_1" doxytag="QGLViewer::QGLViewerIndex"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int QGLViewerIndex </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const QGLViewer *const&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>v</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the index of the QGLViewer <code>v</code> in the <a class="el" href="classQGLViewer.html#z115_0">QGLViewerPool()</a>. This index in unique and can be used to identify the different created QGLViewers (see <a class="el" href="classQGLViewer.html#z113_0">saveToFile()</a> for an application example). When a QGLViewer is deleted, all the next QGLViewers' indexes are shifted.
<p>
Return -1 if the QGLViewer could not be found (which should not be possible).     </td>
  </tr>
</table>
<a name="z115_0" doxytag="QGLViewer::QGLViewerPool"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const QPtrList&lt;QGLViewer&gt;&amp; QGLViewerPool </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This QPtrList (see Qt documentation) holds all the created QGLViewer. If you need to apply a method to <em>all</em> the created viewers, use code like this: <div class="fragment"><pre>  QPtrListIterator&lt;QGLViewer&gt; it(<a class="code" href="classQGLViewer.html#z115_0">QGLViewer::QGLViewerPool</a>());
  <span class="keywordflow">for</span> (<a class="code" href="classQGLViewer.html">QGLViewer</a>* viewer; (viewer = it.current()) != NULL; ++it)
    viewer-&gt;anyAction();
</pre></div> Classical functions are allready implemented : <a class="el" href="classQGLViewer.html#z115_2">connectSignalToAllViewers()</a>, <a class="el" href="classQGLViewer.html#z115_3">disconnectSignalToAllViewers()</a> and <a class="el" href="classQGLViewer.html#z115_4">updateGLForAllViewers()</a>. See also <a class="el" href="classQGLViewer.html#z115_1">QGLViewerIndex()</a>.     </td>
  </tr>
</table>
<a name="z117_2" doxytag="QGLViewer::resetVisualHints"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void resetVisualHints </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reset the mask used by <a class="el" href="classQGLViewer.html#z117_1">drawVisualHints()</a>. Called by <a class="el" href="classQGLViewer.html#z117_0">setVisualHintsMask()</a> after 2 seconds to reset the display.     </td>
  </tr>
</table>
<a name="b0" doxytag="QGLViewer::resizeGL"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void resizeGL </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>w</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>h</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Called when the window size is modified. If you override this function, be very careful to call first the inherited method. <div class="fragment"><pre>  <span class="keywordtype">void</span> Viewer::resizeGL( <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h )
  {
  <a class="code" href="classQGLViewer.html#b0">QGLViewer::resizeGL</a>(w,h);
  <span class="comment">// ...</span>
  }
</pre></div>     </td>
  </tr>
</table>
<a name="z113_1" doxytag="QGLViewer::restoreFromFile"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void restoreFromFile </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const QString &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>fileName</em> = ""          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Restores the QGLViewer from a state saved in <code>fileName</code> with <a class="el" href="classQGLViewer.html#z113_0">saveToFile()</a>.
<p>
If <code>fileName</code> is empty (default), the filename is automatically generated. A directory may also be provided as <code>filename</code>. See the <a class="el" href="classQGLViewer.html#z113_0">saveToFile()</a> documentation.
<p>
You should define your <a class="el" href="classQGLViewer.html#z91_1">manipulatedFrame()</a> <em>before</em> you call this function, so that its previous state can be restored. Initialization code put <em>after</em> this function will override saved values. <div class="fragment"><pre> <span class="keywordtype">void</span> Viewer::init()
 {
 <span class="comment">// declaration of a manipulatedFrame, if any.</span>
 restoreFromFile();
 <span class="comment">// main init code goes here and overrides file savings</span>
 }
</pre></div>
<p>
If you viewer starts with a black screen, remember that the mouse double clicks automatically fits the orientation, zoom and placement of the <a class="el" href="classQGLViewer.html#z91_0">camera()</a>. If sceneCenter() and <a class="el" href="classQGLViewer.html#z89_0">sceneRadius()</a> are properly defined, you no longer should have an empty screen.     </td>
  </tr>
</table>
<a name="b9" doxytag="QGLViewer::rootWidget"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> QWidget * rootWidget </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Recursively call QWidget::parentWidget() until the root widget is found.     </td>
  </tr>
</table>
<a name="z99_3" doxytag="QGLViewer::saveSnapshot"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void saveSnapshot </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>automatic</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>overwrite</em> = false</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Saves a snapshot of the current image displayed by the widget. If no snapshot filename is defined (see <a class="el" href="classQGLViewer.html#z99_0">snapshotFilename()</a>) or if <code>automatic</code> is <code>false</code>, a file dialog is opened to ask for the filename.
<p>
Saving formats are those available in the Qt installation, plus some vectorial formats (EPS, PS, XFIG). See <a class="el" href="classQGLViewer.html#z99_5">setSnapshotFormat()</a>.
<p>
Some artifacts may appear when displaying the PS and EPS result. Simply remove the anti-alias option in ghostview to get the correct display. Printed output will be fine. The libEPSRender library was written by Cyril Soler (<a href="mailto:Cyril.Soler@imag.fr">Cyril.Soler@imag.fr</a>).
<p>
When <code>automatic</code> is <code>true</code> (default is <code>false)</code>, the filename is set to <code>NAME-NUMBER</code>, where <code>NAME</code> is <a class="el" href="classQGLViewer.html#z99_0">snapshotFilename()</a> and <code>NUMBER</code> is <a class="el" href="classQGLViewer.html#z99_2">snapshotCounter()</a>. The <a class="el" href="classQGLViewer.html#z99_2">snapshotCounter()</a> is incremented. This is useful to create videos from your application: <div class="fragment"><pre>  <a class="code" href="classQGLViewer.html#b2">init</a>() { resize(720, 576); } <span class="comment">// PAL DV format (use 720x480 for NTSC DV)</span>

  <a class="code" href="classQGLViewer.html#b6">draw</a>() {
    scene.draw();
    
    <span class="keywordflow">if</span> (makeMovie)
      <a class="code" href="classQGLViewer.html#z99_3">saveSnapshot</a>(<span class="keyword">true</span>, <span class="keyword">true</span>); <span class="comment">// Warning, overwrite mode</span>
  }
</pre></div> Then call <a class="el" href="classQGLViewer.html#b6">draw()</a> in a loop (for instance using <a class="el" href="classQGLViewer.html#z101_6">animate()</a> and/or a <a class="el" href="classQGLViewer.html#z91_0">camera()</a> KeyFrameInterpolator replay) to create your image sequence.
<p>
If you want to create a Quicktime VR panoramic sequence, simply use code like this: <div class="fragment"><pre>  <span class="keywordtype">void</span> Viewer::createQuicktime()
  {
    <span class="keyword">const</span> <span class="keywordtype">int</span> nbImages = 36;
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;nbImages; ++i)
      {
        camera()-&gt;setOrientation(2.0*M_PI/nbImages, 0.0); <span class="comment">// Theta-Phi orientation</span>
        showEntireScene();
        updateGL();  <span class="comment">// calls draw(), which saveSnapshot() as above</span>
      }
  }
</pre></div>
<p>
When <code>overwrite</code> is set to false (default), a pop-up window asks for confirmation (when <code>automatic</code> is <code>false)</code> or the <a class="el" href="classQGLViewer.html#z99_2">snapshotCounter()</a> is incremented until a non-existing file name is found (when <code>automatic</code> is <code>true)</code>.     </td>
  </tr>
</table>
<a name="z113_0" doxytag="QGLViewer::saveToFile"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void saveToFile </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const QString &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>fileName</em> = ""          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Saves in <code>fileName</code> an XML representation of the QGLViewer state, obtained from <a class="el" href="classQGLViewer.html#z113_2">domElement()</a>. Use <a class="el" href="classQGLViewer.html#z113_1">restoreFromFile()</a> to restore the viewer.
<p>
If no <code>filename</code> is provided (default), the generated filename will be ".qglviewer.xml". If several viewers were created in this application, the files will be numbered (".qglviewer0.xml", ".qglviewer1.xml",... See <a class="el" href="classQGLViewer.html#z115_1">QGLViewer::QGLViewerIndex()</a>). Each viewer will then read back its own information in <a class="el" href="classQGLViewer.html#z113_1">restoreFromFile()</a>, provided that the viewers are created in the same order, which is usually the case.
<p>
If <code>filename</code> is a directory, the file name is generated as above and saved in this directory.
<p>
This function is called when a viewer is closed (default key is Escape).     </td>
  </tr>
</table>
<a name="z115_5" doxytag="QGLViewer::saveToFileForAllViewers"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void saveToFileForAllViewers </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classQGLViewer.html#z113_0">saveToFile()</a> is called on all the created QGLViewers using the <a class="el" href="classQGLViewer.html#z115_0">QGLViewerPool()</a>.
<p>
See <a class="el" href="classQGLViewer.html#z115_2">connectSignalToAllViewers()</a> and <a class="el" href="classQGLViewer.html#z115_3">disconnectSignalToAllViewers()</a> for more complex connections.     </td>
  </tr>
</table>
<a name="z89_0" doxytag="QGLViewer::sceneRadius"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> float sceneRadius </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the scene radius (used by the <a class="el" href="classQGLViewer.html#z91_0">camera()</a> to set <a class="el" href="classqglviewer_1_1Camera.html#z7_0">qglviewer::Camera::zNear()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z7_1">qglviewer::Camera::zFar()</a>). The entire scene must be included in a sphere of radius <a class="el" href="classQGLViewer.html#z89_0">sceneRadius()</a>, centered on sceneCenter().
<p>
This function is equivalent to <a class="el" href="classQGLViewer.html#z91_0">camera()</a>-&gt;<a class="el" href="classQGLViewer.html#z89_0">sceneRadius()</a>.     </td>
  </tr>
</table>
<a name="z107_1" doxytag="QGLViewer::select"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void select </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>y</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function performs a selection in the scene from pixel coordinates. It is called when the user clicks on the SELECT ClickAction binded button(s) (default is Shift-LeftButton).
<p>
This function successively calls four other functions: <div class="fragment"><pre>  <a class="code" href="classQGLViewer.html#z107_2">beginSelection</a>(x,y);
  <a class="code" href="classQGLViewer.html#z107_3">drawWithNames</a>();
  <a class="code" href="classQGLViewer.html#z107_4">endSelection</a>(x,y);
  <a class="code" href="classQGLViewer.html#z107_5">postSelection</a>(x,y);
</pre></div>
<p>
The default implementation of these functions is as follows (see the functions' documentation for more details) : <ul>
<li> <a class="el" href="classQGLViewer.html#z107_2">beginSelection()</a> sets the <code>GL_SELECT</code> mode with the appropriate picking matrices.</ul>
<ul>
<li> <a class="el" href="classQGLViewer.html#z107_3">drawWithNames()</a> is empty and should be overloaded to draw your scene with glPushNames() calls.</ul>
<ul>
<li> <a class="el" href="classQGLViewer.html#z107_4">endSelection()</a> restores <code>GL_RENDER</code> mode and set in <a class="el" href="classQGLViewer.html#z107_6">selectedName()</a> the closer picked object, or -1 if not object was picked.</ul>
<ul>
<li> <a class="el" href="classQGLViewer.html#z107_5">postSelection()</a> is empty and can be overloaded for possible signal/display/interface update.</ul>
<code>The</code> GL_SELECT mode works as follows : a square frustum (see <a class="el" href="classQGLViewer.html#z107_10">selectRegionSize()</a>) is created around the mouse cursor by <a class="el" href="classQGLViewer.html#z107_2">beginSelection()</a>. The scene objects are then drawned by <a class="el" href="classQGLViewer.html#z107_3">drawWithNames()</a> which pushes a name (an integer value) before each of them. The names of the objects that draw something in the selection region are recorded in the <a class="el" href="classQGLViewer.html#z107_12">selectBuffer()</a>. <a class="el" href="classQGLViewer.html#z107_4">endSelection()</a> then analyses this buffer and <a class="el" href="classQGLViewer.html#z107_7">setSelectedName()</a> to the name corresponding to the closest object. <a class="el" href="classQGLViewer.html#z107_5">postSelection()</a> can then be used to update the data structure according to this selection. See the glSelectBuffer() man page for details on this mechanism.
<p>
This default implementation is quite limited: only the closer object is selected, and only one level of names can be pushed. However, this reveals sufficient in many cases and you usually only have to overload <a class="el" href="classQGLViewer.html#z107_3">drawWithNames()</a> and maybe <a class="el" href="classQGLViewer.html#z107_5">postSelection()</a>. See the <a href="../examples/select.html">select</a> example for an illustration.
<p>
If you need a more complex selection process (such as a point, edge or triangle selection, which is easier with a 2 or 3 levels heap, and which requires a finer depth sorting to priviledge point over edge and edges over triangles), overload the <a class="el" href="classQGLViewer.html#z107_4">endSelection()</a> method. Use <a class="el" href="classQGLViewer.html#z107_11">setSelectRegionSize()</a>, <a class="el" href="classQGLViewer.html#z107_9">setSelectBufferSize()</a> to tune the select buffer configuration.
<p>
<code>x</code> and <code>y</code> are the pixel coordinates (origin in the upper left corner) where the selection occurs. Use <a class="el" href="classqglviewer_1_1Camera.html#z19_4">qglviewer::Camera::convertClickToLine()</a> to transform these coordinates in a 3D ray if you want to perform an analytical intersection.
<p>
Use <a class="el" href="classQGLViewer.html#z111_2">setMouseBinding()</a> to customize mouse bindings. See also <a class="el" href="classQGLViewer.html#z107_12">selectBuffer()</a>, <a class="el" href="classQGLViewer.html#z107_8">selectBufferSize()</a>, <a class="el" href="classQGLViewer.html#z107_10">selectRegionSize()</a>.     </td>
  </tr>
</table>
<a name="z107_0" doxytag="QGLViewer::select"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void select </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const QMouseEvent *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>e</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Simple wrapper function : calls <code>select(e-&gt;x()</code>, e-&gt;y()).
<p>
Emits <code>pointSelected(e)</code> which is useful only if you rely on the Qt signal-slot mechanism and you did not overload QGLViewer. If you choose to derive your own viewer class, simply overload <a class="el" href="classQGLViewer.html#z107_0">select()</a> (or probably simply <a class="el" href="classQGLViewer.html#z107_3">drawWithNames()</a>, see the <a href="../examples/select.html">select</a> example) to implement your selection mechanism.     </td>
  </tr>
</table>
<a name="z107_12" doxytag="QGLViewer::selectBuffer"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> GLuint* selectBuffer </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns a pointer to an array of <code>GLuint</code>. This buffer is used by the <code>GL_SELECT</code> mode in <a class="el" href="classQGLViewer.html#z107_0">select()</a> to perform object selection. The buffer size can be modified using <a class="el" href="classQGLViewer.html#z107_9">setSelectBufferSize()</a>. If you overload <a class="el" href="classQGLViewer.html#z107_4">endSelection()</a>, you will analyse the content of this buffer. See the glSelectBuffer() man page for details.     </td>
  </tr>
</table>
<a name="z107_8" doxytag="QGLViewer::selectBufferSize"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int selectBufferSize </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the current <a class="el" href="classQGLViewer.html#z107_12">selectBuffer()</a> size. Use <a class="el" href="classQGLViewer.html#z107_9">setSelectBufferSize()</a> to change this value. Default value is 256. This size should be over estimated to prevent a buffer overflow when many objects are drawned under the mouse cursor. The default value should however fit most applications. See the <a class="el" href="classQGLViewer.html#z107_0">select()</a> documentation for details. See also <a class="el" href="classQGLViewer.html#z107_10">selectRegionSize()</a>.     </td>
  </tr>
</table>
<a name="z107_6" doxytag="QGLViewer::selectedName"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int selectedName </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the name (an integer value) of the entity that was last selected by <a class="el" href="classQGLViewer.html#z107_0">select()</a>. This value is set by <a class="el" href="classQGLViewer.html#z107_4">endSelection()</a>. See the <a class="el" href="classQGLViewer.html#z107_0">select()</a> documentation for details.
<p>
As a convention, this function returns -1 if the <a class="el" href="classQGLViewer.html#z107_12">selectBuffer()</a> was empty, meaning that no object was selected. Note that this function returns the same value until <a class="el" href="classQGLViewer.html#z107_7">setSelectedName()</a> is called, which should only be done by <a class="el" href="classQGLViewer.html#z107_4">endSelection()</a>, and hence only when a selection is performed using <a class="el" href="classQGLViewer.html#z107_0">select()</a>.
<p>
Before the first call to <a class="el" href="classQGLViewer.html#z107_0">select()</a>, the return value is -1.     </td>
  </tr>
</table>
<a name="z107_10" doxytag="QGLViewer::selectRegionSize"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int selectRegionSize </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This size (in pixels) is used to define the selection window size created in <a class="el" href="classQGLViewer.html#z107_2">beginSelection()</a>. A square frustum is then created with this side size around the mouse cursor, and the objects that will be drawned in this region by <a class="el" href="classQGLViewer.html#z107_3">drawWithNames()</a> will be recorded in the <a class="el" href="classQGLViewer.html#z107_12">selectBuffer()</a>. <a class="el" href="classQGLViewer.html#z107_4">endSelection()</a> then analyses this buffer and <a class="el" href="classQGLViewer.html#z107_7">setSelectedName()</a> to the closest object name.
<p>
The default value is 4, which is adapted to standard applications. A smaller value results in a more precise but the user has to be careful for small feature selection.     </td>
  </tr>
</table>
<a name="z109_6" doxytag="QGLViewer::setAddKeyFrameStateKey"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setAddKeyFrameStateKey </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>buttonState</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Defines the shortcut state key (Qt::AltButton, Qt::ShiftButton, Qt::ControlButton) that must be pressed in conjunction with the keyFrameKey(i) to add a Key Frame to the camera Key Frame path of index <code>i</code>. Default state key is Qt::AltButton.
<p>
The state key can be set to <code>Qt::NoButton</code>, <code>Qt::ControlButton</code>, <code>Qt::ShiftButton</code>, <code>Qt::AltButton</code>, or a combination of these (use the bit '|' operator, see <a class="el" href="classQGLViewer.html#z111_1">setMouseStateKey()</a>).
<p>
Use <a class="el" href="classQGLViewer.html#z109_4">setKeyFrameKey()</a> to define the associated Key Frame key. See also <a class="el" href="classQGLViewer.html#z109_8">setPlayKeyFramePathStateKey()</a>.
<p>
See the <a href="../shortcuts.html">QGLViewer shortcuts page</a> for details.     </td>
  </tr>
</table>
<a name="z101_2" doxytag="QGLViewer::setAnimationPeriod"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setAnimationPeriod </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>msecs</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the period (in milliseconds) between the calls to <a class="el" href="classQGLViewer.html#z101_6">animate()</a>. Default is 40 msecs (25 Hz). The frame rate (DISPLAY_FPS default binding is 'F') will be set accordingly, provided that your <a class="el" href="classQGLViewer.html#z101_6">animate()</a> function is fast enough.     </td>
  </tr>
</table>
<a name="z85_6" doxytag="QGLViewer::setBackgroundColor"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setBackgroundColor </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const QColor &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>c</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as setBackgroundColor, but with a QColor attribute.     </td>
  </tr>
</table>
<a name="z85_5" doxytag="QGLViewer::setBackgroundColor"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setBackgroundColor </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>r</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>g</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>b</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as <a class="el" href="classQGLViewer.html#z85_4">setBackgroundColor()</a>, but with float parameters.     </td>
  </tr>
</table>
<a name="z85_4" doxytag="QGLViewer::setBackgroundColor"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setBackgroundColor </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>color</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Defines the background color of the viewer: <a class="el" href="classQGLViewer.html#z85_0">backgroundColor()</a> is modified and <code>glClearColor(color.x</code>, color.y, color.z, 1.0) is called. See also <a class="el" href="classQGLViewer.html#z85_7">setForegroundColor()</a> and the QGLWidget::qglColor() and QGLWidget::qglClearColor() documentations.     </td>
  </tr>
</table>
<a name="z91_2" doxytag="QGLViewer::setCamera"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setCamera </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classqglviewer_1_1Camera.html">qglviewer::Camera</a> *const&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>c</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Associate a new <a class="el" href="classqglviewer_1_1Camera.html">qglviewer::Camera</a> to the viewer.
<p>
You should only use this method when you derive a new class from Camera and want to use one of its instances instead of the original class.
<p>
It you simply want to save and restore Camera positions, use <a class="el" href="classqglviewer_1_1Camera.html#z11_3">qglviewer::Camera::addKeyFrame()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z11_4">qglviewer::Camera::playKeyFramePath()</a> instead.
<p>
This method will silently ignore NULL <code>c</code> pointers. The calling method is responsible for deleting the previous camera pointer, if that is intended, in order to prevent memory leaks: <div class="fragment"><pre><span class="keyword">delete</span> <a class="code" href="classQGLViewer.html#z91_0">camera</a>();
<a class="code" href="classQGLViewer.html#z91_2">setCamera</a>(myCamera);
</pre></div>
<p>
All the <code>c</code> <a class="el" href="classqglviewer_1_1Camera.html#z11_1">qglviewer::Camera::keyFrameInterpolator()</a> <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html#j0">qglviewer::KeyFrameInterpolator::interpolated()</a> signals are connected to the viewer updateGL() slot. The connections with the previous viewer's camera are removed.
<p>
The <a class="el" href="classQGLViewer.html#z89_0">sceneRadius()</a> and sceneCenter() of the new <code>c</code> camera are set to the current QGLViewer values.     </td>
  </tr>
</table>
<a name="z87_10" doxytag="QGLViewer::setDisplayFPS"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setDisplayFPS </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>f</em> = true          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the state of <a class="el" href="classQGLViewer.html#z87_2">fpsIsDisplayed()</a>. <a class="el" href="classQGLViewer.html#z95_7">displayFPS()</a> is called or not. See also <a class="el" href="classQGLViewer.html#z87_11">toggleDisplayFPS()</a> and <a class="el" href="classQGLViewer.html#z89_4">currentFPS()</a>.     </td>
  </tr>
</table>
<a name="z87_12" doxytag="QGLViewer::setDisplayZBuffer"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setDisplayZBuffer </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>f</em> = true          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the state of <a class="el" href="classQGLViewer.html#z87_3">zBufferIsDisplayed()</a>. <a class="el" href="classQGLViewer.html#z95_8">displayZBuffer()</a> is called or not. See also <a class="el" href="classQGLViewer.html#z87_13">toggleDisplayZBuffer()</a>.     </td>
  </tr>
</table>
<a name="z87_6" doxytag="QGLViewer::setDrawAxis"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setDrawAxis </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>f</em> = true          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the state of the <a class="el" href="classQGLViewer.html#z87_0">axisIsDrawn()</a>. World axis is drawn or not. See also <a class="el" href="classQGLViewer.html#z87_7">toggleDrawAxis()</a>.     </td>
  </tr>
</table>
<a name="z87_8" doxytag="QGLViewer::setDrawGrid"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setDrawGrid </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>f</em> = true          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the state of the <a class="el" href="classQGLViewer.html#z87_1">gridIsDrawn()</a>. A XY grid is drawn or not. See also <a class="el" href="classQGLViewer.html#z87_9">toggleDrawGrid()</a>.     </td>
  </tr>
</table>
<a name="z87_14" doxytag="QGLViewer::setEnableText"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setEnableText </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>f</em> = true          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the state of <a class="el" href="classQGLViewer.html#z87_4">textIsEnabled()</a> : <a class="el" href="classQGLViewer.html#z95_4">drawText()</a> and <a class="el" href="classQGLViewer.html#z95_5">draw3DText()</a> actually draw text or not (default is yes). See also <a class="el" href="classQGLViewer.html#z87_15">toggleEnableText()</a>.     </td>
  </tr>
</table>
<a name="z85_9" doxytag="QGLViewer::setForegroundColor"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setForegroundColor </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const QColor &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>c</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as setForegroundColor, but with a QColor attribute.     </td>
  </tr>
</table>
<a name="z85_8" doxytag="QGLViewer::setForegroundColor"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setForegroundColor </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>r</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>g</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>b</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as <a class="el" href="classQGLViewer.html#z85_7">setForegroundColor()</a>, but with float parameters.     </td>
  </tr>
</table>
<a name="z85_7" doxytag="QGLViewer::setForegroundColor"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setForegroundColor </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>color</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="z93_3" doxytag="QGLViewer::setFullScreen"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setFullScreen </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>fs</em> = true          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Viewer is set in full screen mode (<code>fs</code> = <code>true</code>, default) or not (<code>fs</code> = <code>false)</code>. Get current value with <a class="el" href="classQGLViewer.html#z93_1">isFullScreen()</a>. See also <a class="el" href="classQGLViewer.html#z93_4">toggleFullScreen()</a> and the STEREO shortcut key (default is 'S', see the <a href="../shortcuts.html">QGLViewer shortcuts page</a>).     </td>
  </tr>
</table>
<a name="z109_4" doxytag="QGLViewer::setKeyFrameKey"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setKeyFrameKey </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>nb</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>key</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Defines the shortcut key associated with the camera Key Frame path of index <code>nb</code>. The number of available indexes is returned by <a class="el" href="classqglviewer_1_1Camera.html#z11_0">qglviewer::Camera::nbPaths()</a>. The default keys are F1..F12 for indexes 0..11.
<p>
Use <a class="el" href="classQGLViewer.html#z109_6">setAddKeyFrameStateKey()</a> and <a class="el" href="classQGLViewer.html#z109_8">setPlayKeyFramePathStateKey()</a> to define the state key that must be pressed with this key to add (or delete) or play the Key Frame.
<p>
To delete a Key Frame path, quickly press twice the <a class="el" href="classQGLViewer.html#z109_5">keyFrameKey()</a> while pressing the <a class="el" href="classQGLViewer.html#z109_7">addKeyFrameStateKey()</a>. Once a path has been delete, trying to re-play the path (using <a class="el" href="classQGLViewer.html#z109_5">keyFrameKey()</a> and <a class="el" href="classQGLViewer.html#z109_9">playKeyFramePathStateKey()</a>) will do nothing until new key frames are added (using <a class="el" href="classQGLViewer.html#z109_5">keyFrameKey()</a> and <a class="el" href="classQGLViewer.html#z109_7">addKeyFrameStateKey()</a>).
<p>
Use <a class="el" href="classQGLViewer.html#z109_0">setShortcutKey()</a> to define other shortcut keys.
<p>
See the <a href="../shortcuts.html">QGLViewer shortcuts page</a> for details.     </td>
  </tr>
</table>
<a name="z91_3" doxytag="QGLViewer::setManipulatedFrame"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setManipulatedFrame </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classqglviewer_1_1ManipulatedFrame.html">qglviewer::ManipulatedFrame</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>fr</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The frame <code>fr</code> becomes the new manipulated frame. The manipulated frame will be moved with the mouse when the associated mouse bindings are used (default is when pressing the <code>Control</code> key with any mouse button). Use <a class="el" href="classQGLViewer.html#z111_2">setMouseBinding()</a> to define new bindings.
<p>
You can use a manipulated frame to move an object in the scene. Your code will look like this (see the <a href="../examples/manipulatedFrame.html">manipulatedFrame</a> example): <div class="fragment"><pre> <span class="keywordtype">void</span> Viewer::init() { setManipulatedFrame(<span class="keyword">new</span> ManipulatedFrame()); }

 <span class="keywordtype">void</span> draw()
 {
  glPushMatrix(); <span class="comment">// Save state</span>
  glMultMatrixd(manipulatedFrame()-&gt;matrix());
  <span class="comment">// Your object drawing code goes here</span>
  glPopMatrix();  <span class="comment">// Restore previous state</span>
 }
</pre></div>
<p>
Since a <a class="el" href="classQGLViewer.html#z91_0">camera()</a> position is defined with a ManipulatedCameraFrame, a Camera frame can be given as a <a class="el" href="classQGLViewer.html#z91_1">manipulatedFrame()</a>. This is useful for an application with several viewers, where the other viewers' cameras are displayed and can be manipulated (with a direct feedback in the other viewer). Use code like: <div class="fragment"><pre><a class="code" href="classQGLViewer.html#z91_3">setManipulatedFrame</a>( otherQGLViewer-&gt;camera()-&gt;frame() );
</pre></div> Defining the <em>own</em> viewer <a class="el" href="classQGLViewer.html#z91_0">camera()</a>-&gt;frame() as the <a class="el" href="classQGLViewer.html#z91_1">manipulatedFrame()</a> is possible and will result in a classical camera manipulation. See the <a href="../examples/luxo.html">Luxo example</a> for an illustration.
<p>
The value of the currently manipulated frame is retrieved with <a class="el" href="classQGLViewer.html#z91_1">manipulatedFrame()</a>.     </td>
  </tr>
</table>
<a name="z111_6" doxytag="QGLViewer::setMouseBinding"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setMouseBinding </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>buttonState</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classQGLViewer.html#z111_14">ClickAction</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>doubleClick</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>buttonBefore</em> = Qt::NoButton</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function lets you associate any ClickAction to any Qt::ButtonState mouse button and state key combination.
<p>
The list of all possible ClickAction, some binding examples and default bindings are provided in the <a href="../mouse.html">mouse page</a>. See the <a href="../examples/keyboardAndMouse.html">keyboardAndMouse</a> example for an illustration.
<p>
The parameters should read : when the <code>buttonState</code> mouse button(s) is (are) pressed (possibly with Alt, Control, Shift or any combination of these; possibly with a <code>doubleClick)</code>, perform <code>action</code>.
<p>
If <code>buttonBefore</code> is specified (valid only when <code>doubleClick</code> is <code>true)</code>, then these mouse buttons have to pressed <em>before</em> the double click occurs in order to perform <code>action</code>. For instance, with the default binding, pressing the right button, then double clicking on the left button will call RAP_FROM_PIXEL, which defines the new <a class="el" href="classqglviewer_1_1Camera.html#z9_0">qglviewer::Camera::revolveAroundPoint()</a> as the point under the mouse cursor (if any).
<p>
If no mouse button is specified in <code>buttonState</code>, the binding will be ignored.
<p>
To discard a specific action mouse binding, use code like: <div class="fragment"><pre>  <a class="code" href="classQGLViewer.html#z111_2">setMouseBinding</a>(myButtonStateKeyCombo, <a class="code" href="classQGLViewer.html#z111_14t15">NO_CLICK_ACTION</a>);
</pre></div>
<p>
See also <a class="el" href="classQGLViewer.html#z111_2">setMouseBinding()</a> and <a class="el" href="classQGLViewer.html#z111_9">setWheelBinding()</a>.     </td>
  </tr>
</table>
<a name="z111_2" doxytag="QGLViewer::setMouseBinding"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setMouseBinding </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>buttonState</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classQGLViewer.html#z111_13">MouseHandler</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>handler</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classQGLViewer.html#z111_0">MouseAction</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>withConstraint</em> = true</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function lets you associate any MouseAction to any Qt::ButtonState mouse button and state key combination. The receiver of the mouse events is a MouseHandler (<code>CAMERA</code> or <code>FRAME)</code>.
<p>
The list of all possible MouseAction, some binding examples and default bindings are provided in the <a href="../mouse.html">mouse page</a>.
<p>
See the <a href="../examples/keyboardAndMouse.html">keyboardAndMouse</a> example for an illustration.
<p>
The parameters should read : when the <code>buttonState</code> mouse button and state key are pressed, activate <code>action</code> on <code>handler</code>. If <code>withConstraint</code> is <code>true</code> (default), the constraint associated with the frame will be enforced.
<p>
If no mouse button is specified in <code>buttonState</code>, the binding will be ignored. If an action was previously associated with this buttonState, it is silently overwritten (use <a class="el" href="classQGLViewer.html#z111_3">mouseAction()</a> to know if the buttonState is already binded).
<p>
To discard a specific mouse binding, use code like: <div class="fragment"><pre>  <a class="code" href="classQGLViewer.html#z111_2">setMouseBinding</a>(myButtonStateKeyCombo, myHandler, <a class="code" href="classQGLViewer.html#z111_0s0">NO_MOUSE_ACTION</a>);
</pre></div>
<p>
See also <a class="el" href="classQGLViewer.html#z111_2">setMouseBinding()</a> and <a class="el" href="classQGLViewer.html#z111_9">setWheelBinding()</a>.     </td>
  </tr>
</table>
<a name="z97_1" doxytag="QGLViewer::setMouseGrabber"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setMouseGrabber </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classqglviewer_1_1MouseGrabber.html">qglviewer::MouseGrabber</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>mg</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Directly defines the QGLViewer's <a class="el" href="classQGLViewer.html#z97_0">mouseGrabber()</a>. You should not call this function directly as <a class="el" href="classQGLViewer.html#z105_3">mouseMoveEvent()</a> already does it using <a class="el" href="classqglviewer_1_1MouseGrabber.html#z79_0">qglviewer::MouseGrabber::checkIfGrabsMouse()</a>.     </td>
  </tr>
</table>
<a name="z111_1" doxytag="QGLViewer::setMouseStateKey"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setMouseStateKey </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classQGLViewer.html#z111_13">MouseHandler</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>mh</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>buttonState</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Associate a given state key (Alt, Shift, Control or a combinaison of these) to a specific MouseHandler. <em>All</em> the mouse handler's associated bindings will then need the specified <code>buttonState</code> key to be activated.
<p>
With this code, <div class="fragment"><pre>  <a class="code" href="classQGLViewer.html#z111_1">setMouseStateKey</a>(<a class="code" href="classQGLViewer.html#z111_13t13">QGLViewer::CAMERA</a>, Qt::AltButton);
  <a class="code" href="classQGLViewer.html#z111_1">setMouseStateKey</a>(<a class="code" href="classQGLViewer.html#z111_13t14">QGLViewer::FRAME</a>,  Qt::NoButton);
</pre></div> you will have to press the <code>Alt</code> key while pressing mouse buttons in order to move the camera, while no key will be needed to move the associated <a class="el" href="classQGLViewer.html#z91_1">manipulatedFrame()</a>.
<p>
This function is provided for convenience but its implementation is basic. Indeed, <em>every</em> action binded to <code>mh</code> has its state keys <em>replaced</em> by <code>buttonState</code>. If the MouseHandler had some actions binded to different state keys, this setting will be lost. You should consider using <a class="el" href="classQGLViewer.html#z111_2">setMouseBinding()</a> for finer tuning.
<p>
The default binding configuration binds <code>Qt::ControlButton</code> to all the <a class="el" href="classQGLViewer.html#z111_13t14">QGLViewer::FRAME</a> actions and Qt::NoButton to <a class="el" href="classQGLViewer.html#z111_13t13">QGLViewer::CAMERA</a> actions. This function hence easily allows you to change the MouseHandler associated key.
<p>
<dl compact><dt><b>Attention: </b></dt><dd>
This function calls <a class="el" href="classQGLViewer.html#z111_2">setMouseBinding()</a>, which ensures that only <em>one</em> action is binded to a given buttonState. If you want to <em>swap</em> the CAMERA and FRAME state keys, you have to use a temporary dummy buttonState (as when you are swapping two variables) or else the first call will overwrite the previous settings : <div class="fragment"><pre>  <span class="comment">// Associate FRAME with Alt (temporary value)</span>
  <a class="code" href="classQGLViewer.html#z111_1">setMouseStateKey</a>(<a class="code" href="classQGLViewer.html#z111_13t14">QGLViewer::FRAME</a>, Qt::Alt);
  <span class="comment">// Control is associated with CAMERA</span>
  <a class="code" href="classQGLViewer.html#z111_1">setMouseStateKey</a>(<a class="code" href="classQGLViewer.html#z111_13t13">QGLViewer::CAMERA</a>, Qt::ControlButton);
  <span class="comment">// And finally, FRAME can be associated with NoButton</span>
  <a class="code" href="classQGLViewer.html#z111_1">setMouseStateKey</a>(<a class="code" href="classQGLViewer.html#z111_13t14">QGLViewer::FRAME</a>, Qt::NoButton);
</pre></div></dl>If you had started with : <div class="fragment"><pre>  <a class="code" href="classQGLViewer.html#z111_1">setMouseStateKey</a>(<a class="code" href="classQGLViewer.html#z111_13t14">QGLViewer::FRAME</a>, Qt::NoButton);
</pre></div> the FRAME bindings would have replaced <em>all</em> the previous CAMERA bindings (as CAMERA uses <code>NoButton</code> by default). A call to : <div class="fragment"><pre>  <a class="code" href="classQGLViewer.html#z111_1">setMouseStateKey</a>(<a class="code" href="classQGLViewer.html#z111_13t13">QGLViewer::CAMERA</a>, Qt::ControlButton);
</pre></div> would then have done nothing as no more actions are binded to the CAMERA.
<p>
See the <a href="../mouse.html">QGLViewer mouse page</a> for details.     </td>
  </tr>
</table>
<a name="z109_8" doxytag="QGLViewer::setPlayKeyFramePathStateKey"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setPlayKeyFramePathStateKey </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>buttonState</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Defines the shortcut state key (Qt::AltButton, Qt::ShiftButton, Qt::ControlButton) that must be pressed in conjunction with the keyFrameKey(i) to start playing the camera Key Frame path of index <code>i</code>. Default state key is Qt::NoButton.
<p>
The state key can be set to <code>Qt::NoButton</code>, <code>Qt::ControlButton</code>, <code>Qt::ShiftButton</code>, <code>Qt::AltButton</code>, or a combination of these (use the bit '|' operator, see <a class="el" href="classQGLViewer.html#z111_1">setMouseStateKey()</a>).
<p>
Use <a class="el" href="classQGLViewer.html#z109_4">setKeyFrameKey()</a> to define the associated Key Frame key. See also <a class="el" href="classQGLViewer.html#z109_6">setAddKeyFrameStateKey()</a>.
<p>
See the <a href="../shortcuts.html">QGLViewer shortcuts page</a> for details.     </td>
  </tr>
</table>
<a name="z89_3" doxytag="QGLViewer::setSceneBoundingBox"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setSceneBoundingBox </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>m</em>[3], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>M</em>[3]</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as <a class="el" href="classQGLViewer.html#z89_8">setSceneBoundingBox()</a>, with float[3] parameters.     </td>
  </tr>
</table>
<a name="z89_8" doxytag="QGLViewer::setSceneBoundingBox"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setSceneBoundingBox </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>m</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>M</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convenient way to call <a class="el" href="classQGLViewer.html#z89_6">setSceneCenter()</a> and <a class="el" href="classQGLViewer.html#z89_5">setSceneRadius()</a> from a Bounding Box of the scene. Equivalent to : <div class="fragment"><pre>    <a class="code" href="classQGLViewer.html#z89_6">setSceneCenter</a>((m+M)/2.0);
    <a class="code" href="classQGLViewer.html#z89_5">setSceneRadius</a>(0.5*(M-m).norm());
</pre></div>     </td>
  </tr>
</table>
<a name="z89_7" doxytag="QGLViewer::setSceneCenter"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setSceneCenter </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>z</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
float version of <a class="el" href="classQGLViewer.html#z89_6">setSceneCenter()</a>.     </td>
  </tr>
</table>
<a name="z89_6" doxytag="QGLViewer::setSceneCenter"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setSceneCenter </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>sc</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the center of the scene, defined in world coordinates. The entire scene should be include in a sphere of radius <a class="el" href="classQGLViewer.html#z89_0">sceneRadius()</a>, centered on sceneCenter(). Default value is (0,0,0), the world coordinate system origin.
<p>
This method should typically be called in the <a class="el" href="classQGLViewer.html#b2">init()</a> function, when the drawn scene is not centered on the world origin (so that <a class="el" href="classQGLViewer.html#z89_0">sceneRadius()</a>, <a class="el" href="classqglviewer_1_1Camera.html#z7_0">qglviewer::Camera::zNear()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z7_1">qglviewer::Camera::zFar()</a> can be tightly fitted to the scene). It should normally not be modified after. See also <a class="el" href="classQGLViewer.html#z89_8">setSceneBoundingBox()</a>. <div class="fragment"><pre>  <span class="keywordtype">void</span> Viewer::init()
    <a class="code" href="classQGLViewer.html#z89_6">setSceneCenter</a>(10,20,0);
    <a class="code" href="classQGLViewer.html#z89_5">setSceneRadius</a>(3.0);
    <a class="code" href="classQGLViewer.html#z89_9">showEntireScene</a>();
  }
</pre></div>
<p>
The <a class="el" href="classqglviewer_1_1Camera.html#z9_0">qglviewer::Camera::revolveAroundPoint()</a> has a different meaning, and is probably the value you want to change while the program is running (see <a class="el" href="classqglviewer_1_1Camera.html#z9_2">qglviewer::Camera::setRevolveAroundPoint()</a>).
<p>
<dl compact><dt><b>Attention: </b></dt><dd>
The <a class="el" href="classqglviewer_1_1Camera.html#z9_0">qglviewer::Camera::revolveAroundPoint()</a> is set to the sceneCenter() value by this method. </dl>    </td>
  </tr>
</table>
<a name="z89_5" doxytag="QGLViewer::setSceneRadius"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setSceneRadius </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>r</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Scene radius is used by the camera to scale axis and grid display, and to optimally set <a class="el" href="classqglviewer_1_1Camera.html#z7_0">qglviewer::Camera::zNear()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z7_1">qglviewer::Camera::zFar()</a>. The entire scene must be included in a sphere centered on sceneCenter(), with radius <a class="el" href="classQGLViewer.html#z89_0">sceneRadius()</a>. Current value can be retrieved from <a class="el" href="classQGLViewer.html#z89_0">sceneRadius()</a>.
<p>
You will typically use this function in <a class="el" href="classQGLViewer.html#b2">QGLViewer::init()</a> : <div class="fragment"><pre>  <a class="code" href="classQGLViewer.html#z89_5">setSceneRadius</a>(3.0);
  <a class="code" href="classQGLViewer.html#z89_9">showEntireScene</a>();
</pre></div>
<p>
The default <a class="el" href="classQGLViewer.html#z89_0">sceneRadius()</a> is 1.0. See also <a class="el" href="classQGLViewer.html#z89_6">setSceneCenter()</a> and <a class="el" href="classQGLViewer.html#z89_8">setSceneBoundingBox()</a>. The <a class="el" href="classQGLViewer.html#z91_0">camera()</a> <a class="el" href="classqglviewer_1_1Camera.html#z5_2">qglviewer::Camera::flySpeed()</a> is set to 1% of this value by this function.
<p>
<dl compact><dt><b>Attention: </b></dt><dd>
If you want to retrieve z-buffer depth from the frame buffer (using <code>glReadPixel(GL_DEPTH_COMPONENT))</code>, you should provide tight bounds on the <a class="el" href="classQGLViewer.html#z89_0">sceneRadius()</a>. See also <a class="el" href="classqglviewer_1_1Camera.html#z7_16">qglviewer::Camera::setZNearCoef()</a>, <a class="el" href="classqglviewer_1_1Camera.html#z7_0">qglviewer::Camera::zNear()</a>, <a class="el" href="classqglviewer_1_1Camera.html#z7_1">qglviewer::Camera::zFar()</a>. </dl>    </td>
  </tr>
</table>
<a name="z107_9" doxytag="QGLViewer::setSelectBufferSize"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setSelectBufferSize </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>size</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Changes the <a class="el" href="classQGLViewer.html#z107_8">selectBufferSize()</a>. The previous <a class="el" href="classQGLViewer.html#z107_12">selectBuffer()</a> is deleted and a new one created.     </td>
  </tr>
</table>
<a name="z107_7" doxytag="QGLViewer::setSelectedName"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setSelectedName </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>id</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the <a class="el" href="classQGLViewer.html#z107_6">selectedName()</a> value. Called by <a class="el" href="classQGLViewer.html#z107_4">endSelection()</a> during a selection.     </td>
  </tr>
</table>
<a name="z107_11" doxytag="QGLViewer::setSelectRegionSize"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setSelectRegionSize </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>size</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Changes the <a class="el" href="classQGLViewer.html#z107_10">selectRegionSize()</a>. Default value is 4 pixels.     </td>
  </tr>
</table>
<a name="z109_0" doxytag="QGLViewer::setShortcutKey"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setShortcutKey </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classQGLViewer.html#z109_10">ShortcutAction</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>key</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>stateKey</em> = -1</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Defines the shortcut key (and optionnally the state key) associated with a given action of the viewer. All the possible <code>action</code> are defined by the <a class="el" href="classQGLViewer.html#z109_10">QGLViewer::ShortcutAction</a> enum.
<p>
<code>key</code> is defined by the Qt::Key enum and is of the form Qt::Key_X (see the Qt documentation). Set the <code>key</code> to <code>0</code> to forbid the action shortcut. <code>stateKey</code> (optional) defines the state key (Alt, Control, ...) associated with this action, just like <a class="el" href="classQGLViewer.html#z109_2">setShortcutStateKey()</a>.
<p>
Use <a class="el" href="classQGLViewer.html#z109_2">setShortcutStateKey()</a> to define a shortcut state key and <a class="el" href="classQGLViewer.html#z109_1">shortcutKey()</a> to get the current value. See also <a class="el" href="classQGLViewer.html#z109_4">setKeyFrameKey()</a> and <a class="el" href="classQGLViewer.html#z111_1">setMouseStateKey()</a>.
<p>
For example, this code defines 'Ctrl-Alt-F' as the new <a class="el" href="classQGLViewer.html#z93_4">toggleFullScreen()</a> shortcut, 'Q' as the new <code>EXIT</code> shortcut key (state key unchanged) and forbids the <a class="el" href="classQGLViewer.html#z87_13">toggleDisplayZBuffer()</a> shortcut: <div class="fragment"><pre>  <a class="code" href="classQGLViewer.html#z109_0">setShortcutKey</a> (<a class="code" href="classQGLViewer.html#z109_10t8">QGLViewer::FULL_SCREEN</a>, Qt::Key_F, Qt::AltButton | Qt::ControlButton);
  <a class="code" href="classQGLViewer.html#z109_0">setShortcutKey</a> (<a class="code" href="classQGLViewer.html#z109_10t5">QGLViewer::EXIT</a>, Qt::Key_Q);
  <a class="code" href="classQGLViewer.html#z109_0">setShortcutKey</a> (<a class="code" href="classQGLViewer.html#z109_10t3">QGLViewer::DISPLAY_Z_BUFFER</a>, 0);
</pre></div>
<p>
See the <a href="../shortcuts.html">QGLViewer shortcuts page</a> for details and default values. See the <a href="../examples/keyboardAndMouse.html">keyboardAndMouse</a> example for a practical illustration.     </td>
  </tr>
</table>
<a name="z109_2" doxytag="QGLViewer::setShortcutStateKey"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setShortcutStateKey </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classQGLViewer.html#z109_10">ShortcutAction</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>buttonState</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Defines the shortcut state key (Qt::AltButton, Qt::ShiftButton, Qt::ControlButton) that should be pressed while pressing a given action <a class="el" href="classQGLViewer.html#z109_1">shortcutKey()</a>. All the possible actions are defined by the ShortcutAction enum.
<p>
The state key can be set to <code>Qt::NoButton</code>, <code>Qt::ControlButton</code>, <code>Qt::ShiftButton</code>, <code>Qt::AltButton</code>, or a combination of these (use the bit '|' operator, see <a class="el" href="classQGLViewer.html#z111_1">setMouseStateKey()</a>).
<p>
For example, this code defines Ctrl-Alt-F as the new <a class="el" href="classQGLViewer.html#z93_4">toggleFullScreen()</a> shortcut: <div class="fragment"><pre>  <a class="code" href="classQGLViewer.html#z109_0">setShortcutKey</a>      (<a class="code" href="classQGLViewer.html#z109_10t8">QGLViewer::FULL_SCREEN</a>, Qt::Key_F);
  <a class="code" href="classQGLViewer.html#z109_2">setShortcutStateKey</a> (<a class="code" href="classQGLViewer.html#z109_10t8">QGLViewer::FULL_SCREEN</a>, Qt::ControlButton | Qt::AltButton);
</pre></div>
<p>
Use <a class="el" href="classQGLViewer.html#z109_0">setShortcutKey()</a> to define the shortcut key and <a class="el" href="classQGLViewer.html#z109_3">shortcutStateKey()</a> to get the current value. See also <a class="el" href="classQGLViewer.html#z109_4">setKeyFrameKey()</a>, <a class="el" href="classQGLViewer.html#z109_6">setAddKeyFrameStateKey()</a>, <a class="el" href="classQGLViewer.html#z109_8">setPlayKeyFramePathStateKey()</a> and <a class="el" href="classQGLViewer.html#z111_1">setMouseStateKey()</a>.
<p>
See the <a href="../shortcuts.html">QGLViewer shortcuts page</a> for details and default values.     </td>
  </tr>
</table>
<a name="z99_6" doxytag="QGLViewer::setSnapshotCounter"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setSnapshotCounter </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>c</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Defines the new <a class="el" href="classQGLViewer.html#z99_2">snapshotCounter()</a> value.     </td>
  </tr>
</table>
<a name="z99_4" doxytag="QGLViewer::setSnapshotFilename"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setSnapshotFilename </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const QString &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>n</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the filename to use when saving snapshot with <a class="el" href="classQGLViewer.html#z99_3">saveSnapshot()</a>. If the filename is relative, the current working directory <em>at the moment of the function call</em> is added. <a class="el" href="classQGLViewer.html#z99_0">snapshotFilename()</a> returns the current snapshot file name.     </td>
  </tr>
</table>
<a name="z99_5" doxytag="QGLViewer::setSnapshotFormat"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setSnapshotFormat </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const QString &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>f</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Defines the snapshot file format. This format will be used by <a class="el" href="classQGLViewer.html#z99_3">saveSnapshot()</a> in automatic mode. In non-automatic mode, this will be the default format of the saveAs dialog box.
<p>
The available formats are those handled by Qt. Classical values are <code>"JPEG"</code> (default <a class="el" href="classQGLViewer.html#z99_1">snapshotFormat()</a>), <code>"PNG"</code>, <code>"PPM, \c "</code>BMP". Use the following code to get the actual list: <div class="fragment"><pre>   QStringList formatList = QImage::outputFormatList();
   <span class="keywordflow">for</span> (QStringList::Iterator it = formatList.begin(); it != formatList.end(); ++it)
     cout &lt;&lt; (*it) &lt;&lt; endl;
</pre></div>
<p>
If the library was compiled with the EPSRender option, three additional vectorial formats are available: <code>"EPS"</code>, <code>"PS"</code> and <code>"XFIG"</code>.
<p>
<dl compact><dt><b>Attention: </b></dt><dd>
No verification is performed on the provided format validity. The next call to <a class="el" href="classQGLViewer.html#z99_3">saveSnapshot()</a> may fail if the format string is not supported by the Qt QImage class. </dl>    </td>
  </tr>
</table>
<a name="z93_5" doxytag="QGLViewer::setStereoDisplay"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setStereoDisplay </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>s</em> = true          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Activates stereo mode (resp. switch back to mono when <code>flag</code> is false). Checks if the display system is able to handle stereovision using QGLWidget::format(). Should be called in <a class="el" href="classQGLViewer.html#b2">init()</a> or toggled with the STEREO shortcut key (default key is 'S', see <a class="el" href="classQGLViewer.html#z93_6">toggleStereoDisplay()</a> and <a class="el" href="classQGLViewer.html#z109_0">setShortcutKey()</a>). Get current value from <a class="el" href="classQGLViewer.html#z93_2">displaysInStereo()</a>.
<p>
The QGLViewer instance must be created with a stereo format to handle stereovision: <div class="fragment"><pre>  QGLFormat format;
  format.setStereoDisplay( TRUE );
  <a class="code" href="classQGLViewer.html">QGLViewer</a> viewer(format);
</pre></div> See the <a href="../examples/stereoViewer.html">stereoViewer</a> example.
<p>
The stereo parameters are defined by the <a class="el" href="classQGLViewer.html#z91_0">camera()</a>. See <a class="el" href="classqglviewer_1_1Camera.html#z21_4">qglviewer::Camera::setIODist()</a>, <a class="el" href="classqglviewer_1_1Camera.html#z21_5">qglviewer::Camera::setDistanceToScreen()</a>, <a class="el" href="classqglviewer_1_1Camera.html#z21_6">qglviewer::Camera::setDistanceToZeroParallaxPlane()</a> and <a class="el" href="classqglviewer_1_1Camera.html#z21_7">qglviewer::Camera::setPhysicalScreenWidth()</a>.     </td>
  </tr>
</table>
<a name="z117_0" doxytag="QGLViewer::setVisualHintsMask"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setVisualHintsMask </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>mask</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>delay</em> = 2000</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Defines the mask that will be used to <a class="el" href="classQGLViewer.html#z117_1">drawVisualHints()</a>. The only available mask is currently 1, corresponding to the display of the <a class="el" href="classqglviewer_1_1Camera.html#z9_0">qglviewer::Camera::revolveAroundPoint()</a>. <a class="el" href="classQGLViewer.html#z117_2">resetVisualHints()</a> is automatically called after <code>delay</code> milliseconds (default is 2 seconds).     </td>
  </tr>
</table>
<a name="z111_9" doxytag="QGLViewer::setWheelBinding"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void setWheelBinding </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>stateKey</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classQGLViewer.html#z111_13">MouseHandler</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>handler</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classQGLViewer.html#z111_0">MouseAction</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>withConstraint</em> = true</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Associates a MouseAction to a mouse wheel event. The wheel event is received by <code>handler</code>. This function is very similar to <a class="el" href="classQGLViewer.html#z111_2">setMouseBinding()</a>, but specific to the wheel.
<p>
In the current implementation only MouseAction::ZOOM can be associated with FRAME.
<p>
CAMERA can receive MouseAction::ZOOM and MouseAction::MOVE_FORWARD.
<p>
See the <a href="../mouse.html">mouse page</a> for a list of all possible MouseAction, some binding examples and default bindings. See the <a href="../examples/keyboardAndMouse.html">keyboardAndMouse</a> example for an illustration.
<p>
The difference between ZOOM and MOVE_FORWARD is that ZOOM speed depends on the distance to the object, while MOVE_FORWARD depends on <a class="el" href="classqglviewer_1_1ManipulatedCameraFrame.html#z63_0">qglviewer::ManipulatedCameraFrame::flySpeed()</a>.     </td>
  </tr>
</table>
<a name="z103_2" doxytag="QGLViewer::shortcutBindingsString"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> QString shortcutBindingsString </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns a QString that describes the application shortcut bindings, and that will be displayed in one of the <a class="el" href="classQGLViewer.html#z103_3">help()</a> window tabs. Default value is a table that describes all the current key bindings. See <a class="el" href="classQGLViewer.html#z109_0">setShortcutKey()</a>, <a class="el" href="classQGLViewer.html#z109_2">setShortcutStateKey()</a> and the <a href="../shortcuts.html">QGLViewer shortcuts page</a> for details on shortcut bindings.
<p>
Overload this function to add your application specific key bindings. <div class="fragment"><pre>  QString myViewer::shortcutBindingsString()<span class="keyword"> const</span>
<span class="keyword">  </span>{
    QString text(<span class="stringliteral">"&lt;table&gt;"</span>);
    text += <span class="stringliteral">"&lt;tr&gt;&lt;td&gt;&lt;b&gt;Ctrl+O&lt;/b&gt;&lt;/td&gt;&lt;td&gt;Opens a new window&lt;/td&gt;&lt;/tr&gt;"</span>;
    text += <span class="stringliteral">"&lt;tr&gt;&lt;td&gt;&lt;b&gt;W&lt;/b&gt;&lt;/td&gt;&lt;td&gt;Adds a watermelon&lt;/td&gt;&lt;/tr&gt;"</span>;
    text += <span class="stringliteral">"&lt;/table&gt;\n&lt;hr&gt;"</span>;

    <span class="comment">// Add default key bindings</span>
    text += <a class="code" href="classQGLViewer.html#z103_2">QGLViewer::shortcutBindingsString</a>();
    <span class="keywordflow">return</span> text;
  }
</pre></div>
<p>
A QString::null value will suppress the "Shortcuts" tab in <a class="el" href="classQGLViewer.html#z103_3">help()</a>.     </td>
  </tr>
</table>
<a name="z109_1" doxytag="QGLViewer::shortcutKey"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> Qt::Key shortcutKey </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classQGLViewer.html#z109_10">ShortcutAction</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>action</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the current shortcut value as defined with <a class="el" href="classQGLViewer.html#z109_0">setShortcutKey()</a>. <code>action</code> is defined by the <a class="el" href="classQGLViewer.html#z109_10">QGLViewer::ShortcutAction</a> enum.
<p>
See the <a href="../shortcuts.html">QGLViewer shortcuts page</a> for details and default values.     </td>
  </tr>
</table>
<a name="z109_3" doxytag="QGLViewer::shortcutStateKey"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> Qt::ButtonState shortcutStateKey </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classQGLViewer.html#z109_10">ShortcutAction</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>action</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the current shortcut state value as defined with <a class="el" href="classQGLViewer.html#z109_0">setShortcutKey()</a>. <code>action</code> is defined by the <a class="el" href="classQGLViewer.html#z109_10">QGLViewer::ShortcutAction</a> enum.
<p>
See the <a href="../shortcuts.html">QGLViewer shortcuts page</a> for details and default values.     </td>
  </tr>
</table>
<a name="z89_9" doxytag="QGLViewer::showEntireScene"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void showEntireScene </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set camera so that the entire scene is visible. This method should be called in <a class="el" href="classQGLViewer.html#b2">init()</a>, usually after <a class="el" href="classQGLViewer.html#z89_5">setSceneRadius()</a>, <a class="el" href="classQGLViewer.html#z89_6">setSceneCenter()</a> or <a class="el" href="classqglviewer_1_1Camera.html#z5_7">qglviewer::Camera::setType()</a>.
<p>
This function simply calls <a class="el" href="classqglviewer_1_1Camera.html#z3_1">qglviewer::Camera::showEntireScene()</a>. It is called in the QGLViewer constructor, but with default scene parameters (<a class="el" href="classQGLViewer.html#z89_0">sceneRadius()</a> = 1.0, sceneCenter()=0,0,0 and <a class="el" href="classqglviewer_1_1Camera.html#z5_3">qglviewer::Camera::type</a>=PERSPECTIVE) that may not correspond to your scene. That is the reason why you should call it in <a class="el" href="classQGLViewer.html#b2">init()</a>, or use <a class="el" href="classQGLViewer.html#z113_1">restoreFromFile()</a> instead.     </td>
  </tr>
</table>
<a name="z99_2" doxytag="QGLViewer::snapshotCounter"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int snapshotCounter </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The current value of the counter used to name snapshots in <a class="el" href="classQGLViewer.html#z99_3">saveSnapshot()</a> when <code>automatic</code> is <code>true</code>. Set using <a class="el" href="classQGLViewer.html#z99_6">setSnapshotCounter()</a>. Default value is 0, and it is incremented after each <code>automatic</code> snapshot. See <a class="el" href="classQGLViewer.html#z99_3">saveSnapshot()</a> for details.     </td>
  </tr>
</table>
<a name="z99_0" doxytag="QGLViewer::snapshotFilename"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const QString&amp; snapshotFilename </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the current snapshot filename. Set by <a class="el" href="classQGLViewer.html#z99_4">setSnapshotFilename()</a>. Used in <a class="el" href="classQGLViewer.html#z99_3">saveSnapshot()</a>.     </td>
  </tr>
</table>
<a name="z99_1" doxytag="QGLViewer::snapshotFormat"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const QString&amp; snapshotFormat </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the current snapshot file format. Defined from the File Dialog window or with <a class="el" href="classQGLViewer.html#z99_5">setSnapshotFormat()</a>. Default value is "JPEG".     </td>
  </tr>
</table>
<a name="z101_3" doxytag="QGLViewer::startAnimation"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void startAnimation </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start the animation loop. <a class="el" href="classQGLViewer.html#z101_6">animate()</a> and <a class="el" href="classQGLViewer.html#b6">draw()</a> will be called in a loop. The loop frequency is defined by <a class="el" href="classQGLViewer.html#z101_1">animationPeriod()</a> (default is 40 msecs=25Hz). See also <a class="el" href="classQGLViewer.html#z101_4">stopAnimation()</a> and <a class="el" href="classQGLViewer.html#z101_6">animate()</a>.
<p>
See the <a href="../examples/animation.html">animation</a> example for illustration.
<p>
You may also be interested in <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html#z57_1">qglviewer::KeyFrameInterpolator::startInterpolation()</a>.     </td>
  </tr>
</table>
<a name="z95_2" doxytag="QGLViewer::startScreenCoordinatesSystem"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void startScreenCoordinatesSystem </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>upward</em> = false          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Use this function when you want to start drawing directly with the 2D screen coordinates system in your <a class="el" href="classQGLViewer.html#b6">draw()</a> function. Once this function has been called, the <code>x</code>, <code>y</code> coordinates correspond to the screen coordinates. The projection matrix is orthographic and <code>glMatrixMode</code> is set to <code>GL_MODELVIEW</code>.
<p>
The coordinates origin (0,0) is in the upper left corner of the window by default. This follows the Qt standards and make it easier to directly use <code>QMouseEvent</code> pos(). However, setting <code>upward</code> to <code>true</code> places the origin in the <em>lower</em> left corner, thus following the GL and mathematical standards. It is always possible to switch between the two representations using <code>newY</code> = <code>height()</code> - <code>y</code>.
<p>
<dl compact><dt><b>Attention: </b></dt><dd>
The <a class="el" href="classQGLViewer.html#z107_0">select()</a> function is sensitive to the orientation of the coordinates system (convertion between screen and GL coordinates). The <code>upward</code> coordinate system will not be compatible with the "classical" <a class="el" href="classQGLViewer.html#z107_0">select()</a> implementation (see the <a href="../examples/select.html">select</a> example), and you should convert the y coordinate using <code>newY</code> = <code>height()</code> - <code>y</code> before calling <a class="el" href="classQGLViewer.html#z107_0">select()</a>.</dl>Use <a class="el" href="classqglviewer_1_1Camera.html#z19_0">qglviewer::Camera::projectedCoordinatesOf()</a> to compute the 2D projection on screen of a 3D point (results have an origin in the upper left corner). See the <a href="../examples/screenCoordSystem.html">screenCoordSystem</a> example for an illustration.
<p>
You may want to change gl state when drawing in 2D, such as for instance : <div class="fragment"><pre>  <a class="code" href="classQGLViewer.html#z95_2">startScreenCoordinatesSystem</a>();

  <span class="comment">// Disable lighting to enforce colors</span>
  glDisable(GL_LIGHTING);

  <span class="comment">// Enable blending to prevent aliassed lines</span>
  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  glEnable(GL_BLEND);
  glEnable(GL_LINE_SMOOTH);

  <span class="comment">// And so on ...</span>
  glDisable(GL_DEPTH_TEST);
  glLineWidth(1.0);

  <span class="comment">// Your drawing code goes here</span>

  <span class="comment">// Restore (or not) previous gl state here</span>
    
  <a class="code" href="classQGLViewer.html#z95_3">stopScreenCoordinatesSystem</a>();
</pre></div>
<p>
You need to call <a class="el" href="classQGLViewer.html#z95_3">stopScreenCoordinatesSystem()</a> at the end of the drawing block to restore the previous camera matrix.     </td>
  </tr>
</table>
<a name="j10" doxytag="QGLViewer::stereoChanged"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void stereoChanged </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>on</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [signal]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This signal is emitted whenever <a class="el" href="classQGLViewer.html#z93_2">displaysInStereo()</a> changes value. This can be done with <a class="el" href="classQGLViewer.html#z93_5">setStereoDisplay()</a> or <a class="el" href="classQGLViewer.html#z93_6">toggleStereoDisplay()</a>.     </td>
  </tr>
</table>
<a name="z101_4" doxytag="QGLViewer::stopAnimation"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void stopAnimation </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Stop an animation started with <a class="el" href="classQGLViewer.html#z101_3">startAnimation()</a> or <a class="el" href="classQGLViewer.html#z101_5">toggleAnimationMode()</a>.     </td>
  </tr>
</table>
<a name="z95_3" doxytag="QGLViewer::stopScreenCoordinatesSystem"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void stopScreenCoordinatesSystem </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function closes the screen coordinates drawing block that was started by <a class="el" href="classQGLViewer.html#z95_2">startScreenCoordinatesSystem()</a>. The <code>GL_MODELVIEW</code> and <code>GL_PROJECTION</code> matrices modified in <a class="el" href="classQGLViewer.html#z95_2">startScreenCoordinatesSystem()</a> are restored. <code>glMatrixMode</code> is set to <code>GL_MODELVIEW</code>.
<p>
<dl compact><dt><b>Attention: </b></dt><dd>
Calling this function when no <a class="el" href="classQGLViewer.html#z95_2">startScreenCoordinatesSystem()</a> was called will probably result in a crash. </dl>    </td>
  </tr>
</table>
<a name="j8" doxytag="QGLViewer::textEnabled"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void textEnabled </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>on</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [signal]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This signal is emitted whenever <a class="el" href="classQGLViewer.html#z87_4">textIsEnabled()</a> changes value. This can be done with <a class="el" href="classQGLViewer.html#z87_14">setEnableText()</a> or <a class="el" href="classQGLViewer.html#z87_15">toggleEnableText()</a>.     </td>
  </tr>
</table>
<a name="z87_4" doxytag="QGLViewer::textIsEnabled"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool textIsEnabled </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns <code>true</code> if <a class="el" href="classQGLViewer.html#z95_4">drawText()</a> and <a class="el" href="classQGLViewer.html#z95_5">draw3DText()</a> actually display text. Set by <a class="el" href="classQGLViewer.html#z87_14">setEnableText()</a> or <a class="el" href="classQGLViewer.html#z87_15">toggleEnableText()</a>. Convenient to remove all the possibly displayed text with a single key.     </td>
  </tr>
</table>
<a name="z105_5" doxytag="QGLViewer::timerEvent"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void timerEvent </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">QTimerEvent *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Overloading of the timer function. Calls <a class="el" href="classQGLViewer.html#z101_6">animate()</a> (if <a class="el" href="classQGLViewer.html#z101_0">animationIsStarted()</a>) and then <a class="el" href="classQGLViewer.html#b6">draw()</a>, at a frequency set by <a class="el" href="classQGLViewer.html#z101_2">setAnimationPeriod()</a>.     </td>
  </tr>
</table>
<a name="z101_5" doxytag="QGLViewer::toggleAnimationMode"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void toggleAnimationMode </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calls <a class="el" href="classQGLViewer.html#z101_3">startAnimation()</a> or <a class="el" href="classQGLViewer.html#z101_4">stopAnimation()</a>, depending on <a class="el" href="classQGLViewer.html#z101_0">animationIsStarted()</a>.     </td>
  </tr>
</table>
<a name="z93_7" doxytag="QGLViewer::toggleCameraMode"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void toggleCameraMode </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [virtual, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Swaps between two predefined camera mouse bindings. This function is provided for backward compatibility since version 1.3.4.
<p>
The first mode makes the camera observe the scene while revolving around the <a class="el" href="classqglviewer_1_1Camera.html#z9_0">qglviewer::Camera::revolveAroundPoint()</a>. The second mode is designed for walkthrough applications and simulates a flying camera.
<p>
Practically, the three mouse buttons are respectly binded to : <ul>
<li> In revolve mode : ROTATE, ZOOM, TRANSLATE. <li> In fly mode : MOVE_FORWARD, LOOK_AROUND, MOVE_BACKWARD.</ul>
The current mode is determined by asking the current binding of ROTATE for the CAMERA (using <a class="el" href="classQGLViewer.html#z111_5">mouseButtonState()</a>). The state key that was previously used to move the camera is preserved.
<p>
The <code>CAMERA_MODE</code> <a class="el" href="classQGLViewer.html#z109_1">QGLViewer::shortcutKey()</a> calls this function (<code>space</code> by default)     </td>
  </tr>
</table>
<a name="z87_17" doxytag="QGLViewer::toggleCameraPathEditor"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void toggleCameraPathEditor </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start/stop the edition of the camera paths (default EDIT_CAMERA_PATHS shortcut key is 'C'). See <a class="el" href="classQGLViewer.html#z87_5">cameraPathIsEdited()</a>. See also <a class="el" href="classQGLViewer.html#z87_16">editCameraPath()</a>.     </td>
  </tr>
</table>
<a name="z87_11" doxytag="QGLViewer::toggleDisplayFPS"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void toggleDisplayFPS </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Toggle the state of <a class="el" href="classQGLViewer.html#z87_2">fpsIsDisplayed()</a>. <a class="el" href="classQGLViewer.html#z95_7">displayFPS()</a> is called or not (default DISPLAY_FPS shortcut key is 'F'). See also <a class="el" href="classQGLViewer.html#z87_10">setDisplayFPS()</a> and <a class="el" href="classQGLViewer.html#z89_4">currentFPS()</a>.     </td>
  </tr>
</table>
<a name="z87_13" doxytag="QGLViewer::toggleDisplayZBuffer"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void toggleDisplayZBuffer </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Toggle the state of <a class="el" href="classQGLViewer.html#z87_3">zBufferIsDisplayed()</a>. <a class="el" href="classQGLViewer.html#z95_8">displayZBuffer()</a> is called or not (default DISPLAY_Z_BUFFER shortcut key is 'Z'). See also <a class="el" href="classQGLViewer.html#z87_12">setDisplayZBuffer()</a>.     </td>
  </tr>
</table>
<a name="z87_7" doxytag="QGLViewer::toggleDrawAxis"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void toggleDrawAxis </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Toggle the state of <a class="el" href="classQGLViewer.html#z87_0">axisIsDrawn()</a>. A world axis is drawn or not (default DRAW_AXIS shortcut key is 'A'). See also <a class="el" href="classQGLViewer.html#z87_6">setDrawAxis()</a>.     </td>
  </tr>
</table>
<a name="z87_9" doxytag="QGLViewer::toggleDrawGrid"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void toggleDrawGrid </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Toggle the state of <a class="el" href="classQGLViewer.html#z87_1">gridIsDrawn()</a> flag. A XY grid is drawn or not (default DRAW_GRID shortcut key is 'G'). See also <a class="el" href="classQGLViewer.html#z87_8">setDrawGrid()</a>.     </td>
  </tr>
</table>
<a name="z87_15" doxytag="QGLViewer::toggleEnableText"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void toggleEnableText </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Toggle the state of <a class="el" href="classQGLViewer.html#z87_4">textIsEnabled()</a> : <a class="el" href="classQGLViewer.html#z95_4">drawText()</a> and <a class="el" href="classQGLViewer.html#z95_5">draw3DText()</a> actually draw text or not (default is yes) (default ENABLE_TEXT shortcut key is '?'). See also <a class="el" href="classQGLViewer.html#z87_14">setEnableText()</a>.     </td>
  </tr>
</table>
<a name="z93_4" doxytag="QGLViewer::toggleFullScreen"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void toggleFullScreen </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Viewer is toggled between normal and full screen mode (FULL_SCREEN shortcut key, default is Alt-Enter, see the <a href="../shortcuts.html">QGLViewer shortcuts page</a>). See <a class="el" href="classQGLViewer.html#z93_3">setFullScreen()</a> and <a class="el" href="classQGLViewer.html#z93_1">isFullScreen()</a>.     </td>
  </tr>
</table>
<a name="z93_6" doxytag="QGLViewer::toggleStereoDisplay"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void toggleStereoDisplay </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, slot]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Toggle the state of <a class="el" href="classQGLViewer.html#z93_2">displaysInStereo()</a> (default STEREO shortcut key is 'S'). See <a class="el" href="classQGLViewer.html#z93_5">setStereoDisplay()</a> for details.
<p>
See the <a href="../examples/stereoViewer.html">stereoViewer</a> example for an illustration.     </td>
  </tr>
</table>
<a name="z115_4" doxytag="QGLViewer::updateGLForAllViewers"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void updateGLForAllViewers </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
updateGL() is called on all the created QGLViewers. All the viewers will have their display updated.
<p>
See also <a class="el" href="classQGLViewer.html#z115_0">QGLViewerPool()</a>. Use <a class="el" href="classQGLViewer.html#z115_2">connectSignalToAllViewers()</a> and <a class="el" href="classQGLViewer.html#z115_3">disconnectSignalToAllViewers()</a> for more complex connections.     </td>
  </tr>
</table>
<a name="j0" doxytag="QGLViewer::viewerInitialized"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void viewerInitialized </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [signal]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Signal emitted by the default <a class="el" href="classQGLViewer.html#b2">QGLViewer::init()</a> function. Connect this signal to the functions that need to be called before any drawing (if any), to initialize your viewer.
<p>
Use this signal-slot mechanism ONLY IF you don't inherit your viewer from QGLViewer (in that case, simply overload the <a class="el" href="classQGLViewer.html#b2">init()</a> function).     </td>
  </tr>
</table>
<a name="z111_10" doxytag="QGLViewer::wheelAction"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classQGLViewer.html#z111_0">QGLViewer::MouseAction</a> wheelAction </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>buttonState</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as <a class="el" href="classQGLViewer.html#z111_3">mouseAction()</a>, but for the wheel action.     </td>
  </tr>
</table>
<a name="z111_12" doxytag="QGLViewer::wheelButtonState"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int wheelButtonState </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classQGLViewer.html#z111_13">MouseHandler</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>mh</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classQGLViewer.html#z111_0">MouseAction</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>ma</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>withConstraint</em> = true</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as <a class="el" href="classQGLViewer.html#z111_5">mouseButtonState()</a>, but for the wheel.
<p>
<dl compact><dt><b>Attention: </b></dt><dd>
Returns -1 when no Qt::ButtonState was associated with this handler/action/withConstraint value. <a class="el" href="classQGLViewer.html#z111_5">mouseButtonState()</a> returns Qt::NoButton is that case as it is an impossible value. </dl>    </td>
  </tr>
</table>
<a name="z105_4" doxytag="QGLViewer::wheelEvent"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void wheelEvent </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">QWheelEvent *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>e</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The wheel associated event is controled using <a class="el" href="classQGLViewer.html#z111_9">setWheelBinding()</a>. Default behavior simulates a ZOOM action. See the <a href="../mouse.html">QGLViewer mouse page</a> and <a class="el" href="classQGLViewer.html#z111_9">setWheelBinding()</a> for details.
<p>
Depending on your system configuration, you may have to actually <em>press</em> the wheel while wheeling.     </td>
  </tr>
</table>
<a name="z111_11" doxytag="QGLViewer::wheelHandler"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int wheelHandler </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>buttonState</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as mouseHandler but for the wheel action.     </td>
  </tr>
</table>
<a name="j7" doxytag="QGLViewer::zBufferDisplayed"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void zBufferDisplayed </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>on</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [signal]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This signal is emitted whenever <a class="el" href="classQGLViewer.html#z87_3">zBufferIsDisplayed()</a> changes value. This can be done with <a class="el" href="classQGLViewer.html#z87_12">setDisplayZBuffer()</a> or <a class="el" href="classQGLViewer.html#z87_13">toggleDisplayZBuffer()</a>.     </td>
  </tr>
</table>
<a name="z87_3" doxytag="QGLViewer::zBufferIsDisplayed"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool zBufferIsDisplayed </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns <code>true</code> if <a class="el" href="classQGLViewer.html#z95_8">displayZBuffer()</a> is called by the viewer. Set by <a class="el" href="classQGLViewer.html#z87_12">setDisplayZBuffer()</a> or <a class="el" href="classQGLViewer.html#z87_13">toggleDisplayZBuffer()</a>.     </td>
  </tr>
</table>
<hr><address style="align: right;"><small>Generated on Fri Apr 30 16:38:23 2004 for libQGLViewer by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>
